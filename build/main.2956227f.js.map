{"version":3,"sources":["src/vanilla/index.ts","src/vanilla/components/alignment.ts","src/vanilla/components/animation.ts","src/vanilla/components/axis.ts","src/vanilla/components/utils.ts","src/vanilla/components/counter.ts","src/vanilla/components/direction.ts","src/vanilla/components/eventStore.ts","src/vanilla/components/vector1d.ts","src/vanilla/components/dragHandler.ts","src/vanilla/components/dragTracker.ts","src/vanilla/components/limit.ts","src/vanilla/components/pxToPercent.ts","src/vanilla/components/scrollBody.ts","src/vanilla/components/scrollBounds.ts","src/vanilla/components/scrollContain.ts","src/vanilla/components/scrollLimit.ts","src/vanilla/components/scrollLooper.ts","src/vanilla/components/scrollProgress.ts","src/vanilla/components/scrollSnap.ts","src/vanilla/components/scrollTarget.ts","src/vanilla/components/scrollTo.ts","src/vanilla/components/slideLooper.ts","src/vanilla/components/slideFocus.ts","src/vanilla/components/slidesInView.ts","src/vanilla/components/translate.ts","src/vanilla/components/engine.ts","src/vanilla/components/eventEmitter.ts","src/vanilla/components/options.ts","node_modules/wowjs/dist/wow.js","assets/js/functions.js","assets/js/main.js"],"names":["Alignment","params","viewSize","align","predefined","start","center","n","end","self","measure","Number","Animation","callback","animationFrame","ifAnimating","active","cb","window","requestAnimationFrame","proceed","stop","cancelAnimationFrame","Axis","axis","scroll","cross","node","_a","getBoundingClientRect","width","height","map","value","iStart","iStop","oStart","oStop","mathSign","Math","abs","deltaAbs","valueB","valueA","factorAbs","diff","roundToDecimals","decimalPoints","pow","round","debounce","time","timeout","clearTimeout","setTimeout","groupArray","array","size","groups","i","length","push","slice","arrayKeys","Object","keys","removeClass","className","cl","classList","contains","remove","addClass","add","Counter","limit","loop","min","max","withinLimit","counter","get","set","sign","clone","Direction","direction","applyTo","EventStore","listeners","type","handler","options","addEventListener","removeEventListener","removeAll","filter","Vector1D","vector","divide","readNumber","multiply","normalize","subtract","DragHandler","target","scrollBody","dragFree","animation","scrollTo","root","dragTracker","location","events","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","dragThreshold","pointerIsDown","preventScroll","preventClick","isMouse","down","evt","button","isMoving","name","clearPreventClick","isNotFocusNode","nodeName","indexOf","preventDefault","pointerDown","useBaseMass","useSpeed","addInteractionEvents","document","move","up","readPoint","emit","cancelable","moveScroll","moveCross","diffScroll","diffCross","pointerMove","rawForce","pointerUp","force","allowedForce","scrollTarget","index","seekNext","byDistance","destination","reachedAny","next","byIndex","distance","speedFactor","click","addActivationEvents","clickAllowed","removeAllEvents","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackInterval","trackLength","trackTime","trackPoints","lastMoveTime","Date","getTime","touches","c","point","nowTime","diffTime","currentPoint","trackPoint","sort","p1","p2","Limit","reachedMin","reachedMax","constrain","removeOffset","PxToPercent","viewInPx","totalPercent","ScrollBody","baseMass","roundToTwoDecimals","velocity","acceleration","attraction","attractionDirection","speed","mass","useMass","seek","v","magnitude","m","applyForce","settle","hasSettled","update","useBaseSpeed","ScrollBounds","pullBackThreshold","disabled","shouldConstrain","friction","diffToTarget","toggleActive","ScrollContain","alignment","contentSize","scrollBounds","alignedWithinView","contentExceedsView","scrollSnaps","trim","containedSnaps","findDuplicates","startSnap","endSnap","lastIndexOf","ScrollLimit","ScrollLooper","vectors","shouldLoop","loopDistance","forEach","ScrollProgress","scrollLength","currentLocation","ScrollSnap","snapSizes","alignments","distancesBetween","sizes","reduce","a","s","ScrollTarget","minDistance","d1","d2","shortcut","t1","t2","t3","shortest","snap","targetSnap","findTargetSnap","scrollSnap","diffToSnap","findTargetIndex","reachedBound","ScrollTo","indexCurrent","indexPrevious","targetDistance","distanceDiff","indexDiff","targetIndex","SlideLooper","gap","scrollLocation","slidesInView","slideSizes","ascItems","descItems","reverse","loopPoints","findLoopPoints","slidesInGap","concat","endPoints","loopStyle","removeSlideSizes","indexes","from","remainingGap","edge","isStartEdge","offset","slideBounds","findSlideBounds","initial","altered","b","getTarget","canLoop","every","clear","slides","style","loopPoint","SlideFocus","slidesToScroll","eventStore","lastTabPressTime","registerTabPress","event","keyCode","addFocusEvent","slide","scrollLeft","selectedIndex","floor","SlidesInView","inViewThreshold","threshold","span","loopOffset","thresholds","check","list","slideBound","Translate","container","containerStyle","translate","transform","to","getComputedStyle","Engine","contentDirection","startIndex","containScroll","slideIndexes","g","defaultSnaps","contain","shouldContain","trimSnaps","engine","dragHandler","settled","scrollLooper","loopVectors","slideLooper","startLocation","scrollProgress","slideFocus","EventEmitter","getListeners","eventListeners","e","off","on","defaultOptions","containerSelector","draggable","draggableClass","draggingClass","selectedClass","EmblaCarousel","sliderRoot","userOptions","debouncedResize","resize","activated","newRootElementSize","rootElementSize","reActivate","reInit","activate","partialOptions","storeElements","Error","selector","sliderContainer","querySelector","Array","prototype","call","children","deActivate","toggleDraggingClass","toggleSelectedClass","inView","slidesNotInView","newOptions","selectedScrollSnap","canScrollNext","canScrollPrev","prev","containerNode","dangerouslyGetEngine","destroy","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","bgSection","querySelectorAll","el","bgSrc","bgUrl","src","parentNode","scrollY","wrap","viewPort","prevBtn","nextBtn","embla","disablePrevAndNextBtns","disablePrevNextBtns","element","documentElement","duration","scrollTop","change","currentTime","animateScroll","val","easeInOutQuad","setupPrevNextBtns","sectionID","getAttribute","sectionTop","offsetTop","sectionHight","offsetHeight","wScroll","nav","els","t","d","toggle","currentTarget","WOW","require","wow","boxClass","animateClass","mobile","live","init","form","xhr","XMLHttpRequest","open","onreadystatechange","readyState","DONE","console","log","status","view","send","FormData","FaqExpand","myEl","faq"],"mappings":";;;;;AAkPC,aAAA,SAAA,IAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,UAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,WCvOeA,SAAAA,EAAUC,GAChBC,IAAAA,EAAoBD,EAAM,SAAhBE,EAAUF,EAAM,MAC5BG,EAAa,CAAEC,MAEZA,WACA,OAAA,GAHmBC,OAMnBA,SAAOC,GACPC,OAAAA,EAAID,GAAK,GAPkBC,IAAG,GAU9BA,SAAAA,EAAID,GACJL,OAAAA,EAAWK,EAebE,MAHiB,CACtBC,QANOA,SAAQH,GACX,MAAiB,iBAAVJ,EAJJD,EAAWS,OAAOR,GAKlBC,EAAWD,GAAOI,KCzBbK,SAAAA,EAAUC,GACpBC,IAAAA,EAAiB,EAEZC,SAAAA,EAAYC,EAAiBC,GAC7B,OAAA,WACDD,MAAaF,GAAgBG,KAI5BZ,SAAAA,IACPS,EAAiBI,OAAOC,sBAAsBN,GAazCJ,MALiB,CACtBW,QAASL,GAAY,EAAMV,GAC3BA,MAAOU,GAAY,EAAOV,GAC1BgB,KAAMN,GAAY,EARXM,WACPH,OAAOI,qBAAqBR,GAC5BA,EAAiB,KCfLS,SAAAA,EAAKC,GACbC,IAAAA,EAAkB,MAATD,EAAe,IAAM,IAa7Bf,MALY,CACjBiB,MARqB,MAATF,EAAe,IAAM,IASjCd,QAPOA,SAAQiB,GACTC,IAAAA,EAAoBD,EAAKE,wBAAvBC,EAAK,EAAA,MAAEC,EAAM,EAAA,OACdN,MAAW,MAAXA,EAAiBK,EAAQC,GAMhCN,OAAM,GCpBMO,SAAAA,EACdC,EACAC,EACAC,EACAC,EACAC,GAEOD,OAAAA,GAA8BH,EAAQC,IAAWC,EAAQD,IAA/CG,EAAQD,GAGXE,SAAAA,EAAS/B,GAChB,OAACA,EAAQA,EAAIgC,KAAKC,IAAIjC,GAAjB,EAGEkC,SAAAA,EAASC,EAAgBC,GAChCJ,OAAAA,KAAKC,IAAIE,EAASC,GAGXC,SAAAA,EAAUF,EAAgBC,GACpCD,GAAW,IAAXA,GAA2B,IAAXC,EAAc,OAAO,EACrCJ,GAAAA,KAAKC,IAAIE,IAAWH,KAAKC,IAAIG,GAAS,OAAO,EAC3CE,IAAAA,EAAOJ,EAASF,KAAKC,IAAIE,GAASH,KAAKC,IAAIG,IAC1CJ,OAAAA,KAAKC,IAAIK,EAAOH,GAGTI,SAAAA,EAAgBC,GACxBC,IAAAA,EAAMT,KAAKS,IAAI,GAAID,GAClB,OAAA,SAACxC,GAAsBgC,OAAAA,KAAKU,MAAM1C,EAAIyC,GAAOA,GAGtCE,SAAAA,EAASrC,EAAsBsC,GACzCC,IAAAA,EAAU,EACP,OAAA,WACLlC,OAAOmC,aAAaD,GACpBA,EAAUlC,OAAOoC,WAAWzC,EAAUsC,IAAS,GAInCI,SAAAA,EACdC,EACAC,GAGK,IADCC,IAAAA,EAAS,GACNC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,GAAKF,EACrCC,EAAOG,KAAKL,EAAMM,MAAMH,EAAGA,EAAIF,IAE1BC,OAAAA,EAGOK,SAAAA,EAAuBP,GAC9BQ,OAAAA,OAAOC,KAAKT,GAAOxB,IAAIrB,QAGhBuD,SAAAA,EAAYvC,EAAmBwC,GACvCC,IAAAA,EAAKzC,EAAK0C,UACZF,GAAaC,EAAGE,SAASH,IAAYC,EAAGG,OAAOJ,GAGrCK,SAAAA,EAAS7C,EAAmBwC,GACpCC,IAAAA,EAAKzC,EAAK0C,UACZF,IAAcC,EAAGE,SAASH,IAAYC,EAAGK,IAAIN,GC1CnCO,SAAAA,EAAQzE,GACdI,IAAAA,EAAuBJ,EAAM,MAAtB0E,EAAgB1E,EAAM,MAAf2E,EAAS3E,EAAM,KAC7B4E,EAAaF,EAAK,IAAbG,EAAQH,EAAK,IAEpBI,EAAcJ,EADPC,EAAO,OAAS,aAEzBI,EAAUD,EAAY1E,GAEjB4E,SAAAA,IACAD,OAAAA,EAGAE,SAAAA,EAAI3E,GAEJE,OADPuE,EAAUD,EAAYxE,GACfE,EAgBHA,IAAAA,EAAgB,CACpBgE,IAdOA,SAAAA,EAAIlE,GACPA,GAAM,IAANA,EAAS,CACL4E,IAAAA,EAAO7C,EAAS/B,GAEfkE,OADPS,EAAID,IAAQE,GACLV,EAAIlE,GAAY,EAAR4E,GAEV1E,OAAAA,GASP2E,MANOA,WACAV,OAAAA,EAAQ,CAAErE,MAAO4E,IAAON,MAAK,EAAEC,KAAI,KAM1CK,IAAG,EACHH,IAAG,EACHD,IAAG,EACHK,IAAG,GAEEzE,OAAAA,ECjDO4E,SAAAA,EAAUC,GAClBH,IAAAA,EAAqB,QAAdG,GAAuB,EAAI,EASjC7E,MAHiB,CACtB8E,QALOA,SAAQhF,GACRA,OAAAA,EAAI4E,ICICK,SAAAA,IACVC,IAAAA,EAA4B,GAoB1BhF,IAAAA,EAAmB,CACvBgE,IAnBOA,SACP9C,EACA+D,EACAC,EACAC,GAMOnF,YANP,IAAA,IAAAmF,GAAAA,GAEAjE,EAAKkE,iBAAiBH,EAAMC,EAASC,GACrCH,EAAU5B,KAAK,WACNlC,OAAAA,EAAKmE,oBAAoBJ,EAAMC,EAASC,KAE1CnF,GAUPsF,UAPOA,WAEAtF,OADPgF,EAAYA,EAAUO,OAAO,SAAAzB,GAAUA,OAAAA,MAChC9D,IAOFA,OAAAA,EC7BOwF,SAAAA,EAAShE,GACnBiE,IAAAA,EAASjE,EA0BJkE,SAAAA,EAAO5F,GAEPE,OADPyF,GAAU3F,EACHE,EAQA2F,SAAAA,EAAW7F,GACX,MAAa,iBAANA,EAAiBA,EAAIA,EAAE0E,MAGjCxE,IAAAA,EAAiB,CACrBgE,IA9BOA,SAAIlE,GAEJE,OADPyF,GAAUE,EAAW7F,GACdE,GA6BP0F,OAAM,EACNlB,IAzCOA,WACAiB,OAAAA,GAyCPG,SAvBOA,SAAS9F,GAETE,OADPyF,GAAU3F,EACHE,GAsBP6F,UAdOA,WAEA7F,OADQ,IAAXyF,GAAcC,EAAOD,GAClBzF,GAaPyE,IAxCOA,SAAI3E,GAEJE,OADPyF,EAASE,EAAW7F,GACbE,GAuCP8F,SA/BOA,SAAShG,GAETE,OADPyF,GAAUE,EAAW7F,GACdE,IA+BFA,OAAAA,ECtBO+F,SAAAA,EAAYvG,GAClBwG,IAAAA,EAA4DxG,EAAM,OAA1DyG,EAAoDzG,EAAM,WAA9C0G,EAAwC1G,EAAM,SAApC2G,EAA8B3G,EAAM,UAAzBuB,EAAmBvB,EAAM,KAAnB4G,EAAa5G,EAAM,SAClE6G,EAA0D7G,EAAM,KAA1D8G,EAAoD9G,EAAM,YAA7C+G,EAAuC/G,EAAM,SAAnCgH,EAA6BhH,EAAM,OAA3B0E,EAAqB1E,EAAM,MAApBqF,EAAcrF,EAAM,UACxDiH,EAAiC1F,EAAI,OAAlB2F,EAAc3F,EAAI,MAC/C4F,EAAa,CAAC,QAAS,SAAU,YACjCC,EAAcpB,EAAS,GACvBqB,EAAarB,EAAS,GACtBsB,EAAiBtB,EAAS,GAC1BuB,EAAmBhC,IACnBiC,EAAoBjC,IACpBkC,EAAiB,CAAEC,MAAO,IAAKC,MAAO,KACtCC,EAAiB,CAAEF,MAAO,EAAGC,MAAO,GACpCE,EAAYnB,EAAW,EAAI,GAC3BoB,EAAgB,EAElBC,GAAgB,EAChBC,GAAgB,EAChBC,GAAe,EACfC,GAAU,EAqDLC,SAAAA,EAAKC,GAERF,KADJA,EAAuB,cAAbE,EAAI3C,OACgC,IAA9B2C,EAAmBC,OAA/BH,CAEEI,IA7Ba5G,EACb6G,EA4BAD,EAAW9F,EAASgE,EAAOxB,MAAO+B,EAAS/B,QAAU,EACrDwD,EAAoBN,IAAYI,EAChCG,GA/Ba/G,EA+BiB0G,EAAI5B,OA9BlC+B,EAAO7G,EAAKgH,UAAY,KACvBvB,EAAWwB,QAAQJ,IAAS,IA8B7BK,EAAiBN,GAAaJ,GAAWO,EAE/CV,GAAgB,EAChBjB,EAAY+B,YAAYT,GACxBd,EAAerC,IAAIuB,GACnBA,EAAOvB,IAAI8B,GACXN,EAAWqC,cAAcC,SAAS,IApD3BC,WACDtH,IAAAA,EAAQwG,EAAiBe,SAAPpC,EACxBW,EACGhD,IAAI9C,EAAM,YAAawH,GACvB1E,IAAI9C,EAAM,WAAYyH,GACtB3E,IAAI9C,EAAM,YAAawH,GACvB1E,IAAI9C,EAAM,UAAWyH,GA+CxBH,GACA5B,EAAYnC,IAAI6B,EAAYsC,UAAUhB,EAAKnB,IAC3CI,EAAWpC,IAAI6B,EAAYsC,UAAUhB,EAAKlB,IAC1CF,EAAOqC,KAAK,eAERb,IAAmBP,GAAe,GAClCW,GAAgBR,EAAIQ,kBAGjBM,SAAAA,EAAKd,GACR,IAACJ,IAAkBE,EAAS,CAC1B,IAACE,EAAIkB,WAAY,OAAOH,IACtBI,IAAAA,EAAazC,EAAYsC,UAAUhB,EAAKnB,GAAYjC,MACpDwE,EAAY1C,EAAYsC,UAAUhB,EAAKlB,GAAWlC,MAClDyE,EAAajH,EAAS+G,EAAYnC,EAAYpC,OAC9C0E,EAAYlH,EAASgH,EAAWnC,EAAWrC,OAE7C,KADJgD,EAAgByB,EAAaC,KACNzB,EAAc,OAAOkB,IAExCvG,IAAAA,EAAOkE,EAAY6C,YAAYvB,IAChCH,GAAgBrF,IAAMqF,GAAe,GAC1CtB,EAAUvG,QACVoG,EAAOhC,IAAIa,EAAUC,QAAQ1C,IAC7BwF,EAAIQ,iBAGGO,SAAAA,IACDS,IAAAA,EAAW9C,EAAY+C,aA5DfnD,EAAWkB,EAAiBH,GAC7BS,EAAU,QAAU,SA4D3B4B,EAxDCC,SAAaD,GACZE,IAAAA,EAAwBhK,EAAM,aAAhBiK,EAAUjK,EAAM,MAGhCkK,IAFkBF,EAAaG,WAAW,GAAG,GACbF,QAAUA,EAAMjF,QACnB1C,KAAKC,IAAIuH,GAAShC,EAC/CsC,EAAcN,EAAQ/C,EAAS/B,MAEjCkF,GAAAA,IAAaxD,IAAahC,EAAM2F,WAAWD,GAAc,CACrDE,IAAAA,EAAOL,EAAM9E,QAAQX,KAAuB,EAAnBnC,EAASyH,IACjCE,OAAAA,EAAaO,QAAQD,EAAKtF,MAAO,GAAGwF,SAEtCR,OAAAA,EAAaG,WAAWL,GAAQpD,GAAU8D,SA6CnCT,CAAa1E,EAAUC,QAAQsE,IACvCa,EAAc9H,EAAUiH,EAAUE,GACvBtH,EAASgE,EAAOxB,MAAOsC,EAAetC,QAAU,KAEhDkD,IAASD,GAAe,GACzCD,GAAgB,EAChBD,GAAgB,EAChBP,EAAkB1B,YAClBW,EAAWsC,SAASlB,EAAYA,EAAY4C,GAC5C7D,EAAS4D,SAASV,GAAQpD,GAC1BwB,GAAU,EACVlB,EAAOqC,KAAK,aAGLqB,SAAAA,EAAMtC,GACTH,GAAcG,EAAIQ,iBAiBjBpI,MANmB,CACxBmK,oBAxHOA,WACDjJ,IAAAA,EAAOmF,EACbU,EACG/C,IAAI9C,EAAM,YAAa,cACvB8C,IAAI9C,EAAM,WAAY,cACtB8C,IAAI9C,EAAM,aAAcyG,GACxB3D,IAAI9C,EAAM,YAAayG,GACvB3D,IAAI9C,EAAM,cAAeyH,GACzB3E,IAAI9C,EAAM,cAAeyH,GACzB3E,IAAI9C,EAAM,QAASgJ,IAgHtBE,aAVOA,WACA,OAAC3C,GAURY,YAPOA,WACAd,OAAAA,GAOP8C,gBAtGOA,WACPtD,EAAiBzB,YACjB0B,EAAkB1B,cCjENgF,SAAAA,EAAY9K,GAClBuB,IAAAA,EAAsBvB,EAAM,KAAtB+K,EAAgB/K,EAAM,YACpBiH,EAAe1F,EAAI,OAC7ByJ,EAAS,CAAEC,EAAG,UAAWC,EAAG,WAC5BC,EAAYnF,EAAS,GACrBoF,EAAWpF,EAAS,GACpBqF,EAAWrF,EAAS,GACpBsF,EAAatF,EAAS,GACtBuF,EAAgB,GAChBC,EAAc,EACdC,EAAY,IACdC,EAAwB,GACxBC,GAAe,IAAIC,MAAOC,UAC1B3D,GAAU,EAELkB,SAAAA,EAAUhB,EAAU3C,GAC3ByC,GAAWE,EAAI0D,QACTC,IAAAA,EAAIf,EAAOvF,GACXzD,EAAQkG,EAAUE,EAAI2D,GAAK3D,EAAI0D,QAAQ,GAAGC,GACzCT,OAAAA,EAAWrG,IAAIjD,GA+CjBxB,MANmB,CACxBqI,YAvCOA,SAAYT,GACb4D,IAAAA,EAAQ5C,EAAUhB,EAAKnB,GAGtB8D,OAFPI,EAAUlG,IAAI+G,GACdX,EAASpG,IAAI+G,GACNjB,EAAYtK,QAAQ0K,EAAUnG,QAoCrC2E,YAjCOA,SAAYvB,GACb4D,IAAAA,EAAQ5C,EAAUhB,EAAKnB,GACvBgF,GAAU,IAAIL,MAAOC,UACrBK,EAAWD,EAAUN,EAUpBZ,OARHmB,GAAYX,IACVW,GAAYT,IAAWC,EAAc,IACzCA,EAAY9H,KAAKoI,EAAMhH,OACvB2G,EAAeM,GAGjBb,EAASnG,IAAI+G,GAAO1F,SAAS+E,GAC7BA,EAASpG,IAAI+G,GACNjB,EAAYtK,QAAQ2K,EAASpG,QAqBpC6E,UAlBOA,WACDoC,IACAC,GADU,IAAIN,MAAOC,UACAF,EACrBQ,EAAed,EAASrG,MAExB8E,EAAQ4B,EACX7H,OAAO2H,GACPzJ,IAAI,SAAAqK,GAAcD,OAAAA,EAAeC,IACjCC,KAAK,SAACC,EAAIC,GAAQjK,OAAAA,KAAKC,IAAI+J,GAAMhK,KAAKC,IAAIgK,GAAM,GAAK,IAAI,GAIrDxB,OAFPM,EAASpG,IAAIiH,EAAWT,IAAc3B,EAAQ,EAAIA,GAClD4B,EAAc,GACPX,EAAYtK,QAAQ4K,EAASrG,QAOpCoE,UAAS,GC/DGoD,SAAAA,EAAMxM,GACZ4E,IAAAA,EAAa5E,EAAM,IAAd6E,EAAQ7E,EAAM,IACrB2D,EAASrB,KAAKC,IAAIqC,EAAMC,GAErB4H,SAAAA,EAAWnM,GACXA,OAAAA,EAAIsE,EAGJ8H,SAAAA,EAAWpM,GACXA,OAAAA,EAAIuE,EAGJwF,SAAAA,EAAW/J,GACXmM,OAAAA,EAAWnM,IAAMoM,EAAWpM,GA+B9BE,MAXa,CAClBmM,UANOA,SAAUrM,GACb,OAAC+J,EAAW/J,GACTmM,EAAWnM,GAAKsE,EAAMC,EADFvE,GAM3BqD,OAAM,EACNgB,KAbOA,SAAKrE,GACR,OAAC+J,EAAW/J,GACTmM,EAAWnM,GAAKuE,EAAMD,EADFtE,GAa3BuE,IAAG,EACHD,IAAG,EACHyF,WAAU,EACVqC,WAAU,EACVD,WAAU,EACVG,aA1BOA,SAAatM,GAChBsE,GAAAA,IAAQC,EAAK,OAAOvE,EACjBmM,KAAAA,EAAWnM,IAAIA,GAAKqD,EACpB+I,KAAAA,EAAWpM,IAAIA,GAAKqD,EACpBrD,OAAAA,IChCKuM,SAAAA,EAAYC,GACpBC,IAAAA,EAAe,IAUdvM,MAJmB,CACxBC,QALOA,SAAQH,GACPA,OAAAA,EAAIwM,EAAYC,GAKxBA,aAAY,GCMAC,SAAAA,EAAWhN,GACjB+G,IAAAA,EAA+C/G,EAAM,SAApC6H,EAA8B7H,EAAM,MAAnBiN,EAAajN,EAAM,KACvDkN,EAAqBrK,EAAgB,GACrCsK,EAAWnH,EAAS,GACpBoH,EAAepH,EAAS,GACxBqH,EAAarH,EAAS,GAExBsH,EAAsB,EACtBC,EAAQ1F,EACR2F,EAAOP,EAsCFlE,SAAAA,EAASzI,GAETE,OADP+M,EAAQjN,EACDE,EAGAiN,SAAAA,EAAQnN,GAERE,OADPgN,EAAOlN,EACAE,EAWHA,IAAAA,EAAmB,CACvB6E,UAvBOA,WACAiI,OAAAA,GAuBPI,KA7COA,SAAKC,GACZN,EAAWpI,IAAI0I,GAAGrH,SAASS,GACrB6G,IACAC,EAAI9L,EADQsL,EAAWrI,MACJ,EAAG,IAAK,EAAGuI,GAO7B/M,OANP8M,EAAsBjL,EAASgL,EAAWrI,OAC1CqI,EACGhH,YACAD,SAASyH,GACTvH,SAAS6G,GAbLW,SAAWH,GAClBA,EAAEzH,OAAOsH,GACTJ,EAAa5I,IAAImJ,GAYjBG,CAAWT,GACJ7M,GAoCPuN,OAjCOA,SAAOJ,GACR/K,IAAAA,EAAO+K,EAAE3I,MAAQ+B,EAAS/B,MAE1BgJ,GADcd,EAAmBtK,GAGhCoL,OADHA,GAAYjH,EAAS9B,IAAI0I,GACtBK,GA6BPC,OA1DOA,WACPd,EAAS3I,IAAI4I,GACbrG,EAASvC,IAAI2I,GACbC,EAAahH,SAAS,IAwDtB0C,YATOA,WACA2E,OAAAA,EAAQR,IASfiB,aAdOA,WACAnF,OAAAA,EAASlB,IAchB4F,QAAO,EACP1E,SAAQ,GAEHvI,OAAAA,EChFO2N,SAAAA,EAAanO,GACnB0E,IAAAA,EAAgC1E,EAAM,MAA/B+G,EAAyB/G,EAAM,SAArByG,EAAezG,EAAM,WACxCoO,EAAoB,GACtBC,GAAW,EA8BR7N,MAJoB,CACzBmM,UAlBOA,SAAUnG,EAAkBqC,GAC/B,GARGyF,SAAgB9H,GACnB6H,OAAAA,KACC3J,EAAM2F,WAAW7D,EAAOxB,UACxBN,EAAM2F,WAAWtD,EAAS/B,OAK1BsJ,CAAgB9H,GAAjB,CACE+H,IAAAA,EAAW1F,EAAc,GAAM,GAC/B2F,EAAehI,EAAOxB,MAAQ+B,EAAS/B,MAE7CwB,EAAOF,SAASkI,EAAeD,IAE1B1F,GAAevG,KAAKC,IAAIiM,GAAgBJ,IAC3C5H,EAAOvB,IAAIP,EAAMiI,UAAUnG,EAAOxB,QAClCyB,EAAWsC,SAAS,IAAI0E,QAAQ,MAUlCgB,aANOA,SAAa1N,GACpBsN,GAAYtN,IC1BA2N,SAAAA,EAAc1O,GACpB2O,IAAAA,EAAqC3O,EAAM,UAAhC4O,EAA0B5O,EAAM,YAAnBC,EAAaD,EAAM,SAC7C6O,EAAerC,EAAM,CAAE5H,KAAMgK,EAAc3O,EAAU4E,IAAK,IAC1DiK,EAAoB,CAACH,EAAUlO,QAAQmO,IACvCG,EAAqBH,EAAc3O,EAsBlCO,MAHqB,CAC1BC,QAVOA,SAAQuO,EAAuBC,GAChCC,IAAAA,EAAiBF,EAAYjN,IAAI8M,EAAalC,WAC9ChL,EAVCwN,SAAeH,GAChBI,IAAAA,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYrL,OAAS,GAG1C6I,OAAAA,EAAM,CAAE5H,IAFHoK,EAAYM,YAAYF,GAAa,EAE7BvK,IADRmK,EAAYrG,QAAQ0G,KAMXF,CAAeD,GAA5BtK,EAAG,EAAA,IAAEC,EAAG,EAAA,IAEZ,OAACkK,EACAE,EACEC,EAAerL,MAAMe,EAAM,EAAGC,EAAM,GADzBqK,EADcJ,ICtBpBS,SAAAA,EAAYvP,GAClB4O,IAAAA,EAAsB5O,EAAM,YAAf2E,EAAS3E,EAAM,KAa7BQ,MAHmB,CACxBC,QATOA,SAAQuO,GACTI,IAAAA,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYrL,OAAS,GAG1C6I,OAAAA,EAAM,CAAE5H,IAFHD,EAAOyK,EAAYR,EAAcS,EAEzBxK,IADRuK,MCHAI,SAAAA,EAAaxP,GACnB4O,IAAAA,EAA8C5O,EAAM,YAAvC+G,EAAiC/G,EAAM,SAA7B0E,EAAuB1E,EAAM,MAAtB+K,EAAgB/K,EAAM,YAGtD2B,EAA6B6K,EAAM,CAAE5H,IAF/BF,EAAME,IAAMmG,EAAYtK,QAAQ,IAEIoE,IADpCH,EAAMG,IAAMkG,EAAYtK,QAAQ,MACpCgM,EAAU,EAAA,WAAEC,EAAU,EAAA,WAkBvBlM,MAHoB,CACzBmE,KAROA,SAAK8K,EAAqBpK,GAC7B,GAPGqK,SAAWrK,GACdA,OAAc,IAAdA,EAAwBqH,EAAW3F,EAAS/B,QAC7B,IAAfK,GAAyBoH,EAAW1F,EAAS/B,OAK5C0K,CAAWrK,GAAZ,CAEEsK,IAAAA,EAAef,IAA4B,EAAbvJ,GACpCoK,EAAQG,QAAQ,SAAAjC,GAAKA,OAAAA,EAAEnJ,IAAImL,QCrBfE,SAAAA,EAAe7P,GACvB2B,IAAAA,EAAgC3B,EAAO0E,MAArCG,EAAG,EAAA,IAAUiL,EAAY,EAAA,OAU1BtP,MAHsB,CAC3BwE,IANOA,SAAI1E,GAEJyP,OADiBzP,EAAIuE,IACFiL,ICDdE,SAAAA,EAAWhQ,GACjBiQ,IAMAlL,EANAkL,EAA+BjQ,EAAM,UAA1B2O,EAAoB3O,EAAM,UAAf2E,EAAS3E,EAAM,KACvCkQ,EAAaD,EAAUlO,IAAI4M,EAAUlO,SACrC0P,GAIEpL,EAAUN,EAAQ,CAAEC,MADZ8H,EAAM,CAAE5H,IAAK,EAAGC,IAAKoL,EAAUtM,OAAS,IACrBvD,MAAO,EAAGuE,KAAI,IAExCsL,EAAUlO,IAAI,SAACyB,EAAMyG,GACpBK,IAAAA,EAAOvF,EAAQE,IAAIgF,EAAQ,GAAGjF,MAC7BxB,OAAAA,EAAO0M,EAAWjG,GAASiG,EAAW5F,MAY1C9J,MAHkB,CACvBC,QANOA,SAAQwJ,GAERmG,OADOD,EAAiBtM,MAAM,EAAGoG,GAC3BoG,OAAO,SAACC,EAAGC,GAAMD,OAAAA,EAAIC,GAAGL,EAAW,MCPpCM,SAAAA,EAAaxQ,GACnB2E,IAAAA,EAA0C3E,EAAM,KAA1C0E,EAAoC1E,EAAM,MAAnCgP,EAA6BhP,EAAM,YAAtB4O,EAAgB5O,EAAM,YAChD0M,EAAyChI,EAAK,WAAlC2F,EAA6B3F,EAAK,WAAtBkI,EAAiBlI,EAAK,aAE7C+L,SAAAA,EAAYC,EAAYC,GACxBrO,OAAAA,KAAKC,IAAImO,GAAMpO,KAAKC,IAAIoO,GAAMD,EAAKC,EAenCC,SAAAA,EAASpK,EAAgBnB,GAC1BwL,IAAAA,EAAKrK,EACLsK,EAAKtK,EAASoI,EACdmC,EAAKvK,EAASoI,EAEhB,IAACjK,EAAM,OAAOkM,EACd,IAACxL,EAAW,OAAOoL,EAAYA,EAAYI,EAAIC,GAAKC,GAElDC,IAAAA,EAAWP,EAAYI,EAAkB,IAAdxL,EAAkByL,EAAKC,GACjDzO,OAAAA,KAAKC,IAAIyO,GAAY3L,EAoCvB7E,MALoB,CACzB2J,WAfOA,SAAWK,EAAkByG,GAC9BzK,IAAAA,EAASxG,EAAOwG,OAAOxB,MAAQwF,EAC/B0G,EAxCCC,SAAe3K,GAChBgE,IAAAA,EAAWoC,EAAapG,GAQvB,MAAA,CAAEyD,MAPe+E,EACrBjN,IAAI,SAAAqP,GAAcA,OAAAA,EAAa5G,IAC/BzI,IAAI,SAAAsP,GAAcT,OAAAA,EAASS,EAAY,KACvCtP,IAAI,SAACa,EAAMc,GAAO,MAAA,CAAEd,KAAI,EAAEqH,MAAOvG,KACjC2I,KAAK,SAACqE,EAAIC,GAAOrO,OAAAA,KAAKC,IAAImO,EAAG9N,MAAQN,KAAKC,IAAIoO,EAAG/N,QAElB,GAAhB,MACF4H,SAAQ,GA+BL2G,CAAe3K,GAC5ByD,EAjBCqH,SAAgB9K,EAAgByD,GAEnC,GADkBtF,IAAQ0F,EAAW7D,GACtB,OAAOyD,EAEpBtI,IAAAA,EAAe3B,EAAOiK,MAApBrF,EAAG,EAAA,IAAEC,EAAG,EAAA,IACT6H,OAAAA,EAAWlG,GAAU5B,EAAMC,EAYpByM,CAAgB9K,EAAQ0K,EAAWjH,OAC3CsH,GAAgB5M,GAAQ0F,EAAW7D,GAErC,OAACyK,GAAQM,EAAqB,CAAEtH,MAAK,EAAEO,SAAQ,GAK5C,CAAEP,MAAK,EAAEO,SAFKA,EAAWoG,EADb5B,EAAY/E,GAASiH,EAAW1G,SACE,KAOrDD,QAtBOA,SAAQN,EAAe5E,GAGvB,MAAA,CAAE4E,MAAK,EAAEO,SADCoG,EADE5B,EAAY/E,GAASjK,EAAOwG,OAAOxB,MAChBK,KAqBtCuL,SAAQ,GCnEIY,SAAAA,EAASxR,GACRyR,IAAAA,EAA0CzR,EAAM,MAAlCgK,EAA4BhK,EAAM,aAApB2G,EAAc3G,EAAM,UACvD0R,EAAkD1R,EAAM,cAAzCgH,EAAmChH,EAAM,OAAzB2R,EAAmB3R,EAAM,OAEvD4G,SAAAA,EAASJ,GACVoL,IAAAA,EAAepL,EAAOgE,SACtBqH,EAAYrL,EAAOyD,QAAUwH,EAAazM,MAE5C4M,IACFjL,EAAUvG,QACVuR,EAAenN,IAAIoN,IAEjBC,IACFH,EAAczM,IAAIwM,EAAazM,OAC/ByM,EAAaxM,IAAIuB,EAAOyD,OACxBjD,EAAOqC,KAAK,WAmBT7I,MAJgB,CACrBgK,SAZOA,SAASlK,EAAW2Q,GAE3BrK,EADeoD,EAAaG,WAAW7J,EAAG2Q,KAY1ChH,MAROA,SAAM3J,EAAW+E,GAClByM,IAAAA,EAAcL,EAAatM,QAAQF,IAAI3E,GAE7CsG,EADeoD,EAAaO,QAAQuH,EAAY9M,MAAOK,MCb3C0M,SAAAA,EAAY/R,GAClBuB,IAqCAyQ,EArCAzQ,EAA4DvB,EAAM,KAAlDiS,EAA4CjS,EAAM,SAAlCkS,EAA4BlS,EAAM,aAApBqF,EAAcrF,EAAM,UAClE4O,EAAmD5O,EAAM,YAA5CC,EAAsCD,EAAM,SAAlCmS,EAA4BnS,EAAM,WAAtBgP,EAAgBhP,EAAM,YAC3DoS,EAAWtO,EAAUqO,GACrBE,EAAYvO,EAAUqO,GAAYG,UAClCC,GAiCEP,EAAMhD,EAAY,GAAK,EAEtBwD,EADSC,EAAYJ,EAAWL,GACR,QAnCAU,OAsCxBC,WACDX,IAAAA,EAAM/R,EAAW+O,EAAY,GAAK,EAEjCwD,OAAAA,EADSC,EAAYL,EAAUJ,GACP,SAzCOW,IAClCC,EAA4B,MAAhBrR,EAAKC,OAAiB,OAAS,MAExCqR,SAAAA,EAAiBC,EAAmBC,GACpCD,OAAAA,EAAQzC,OAAO,SAACC,EAAW5M,GACzB4M,OAAAA,EAAI6B,EAAWzO,IACrBqP,GAGIN,SAAAA,EAAYK,EAAmBd,GAC/Bc,OAAAA,EAAQzC,OAAO,SAACC,EAAa5M,GAE3BsP,OADcH,EAAiBvC,EAAG0B,GACnB,EAAI1B,EAAEoC,OAAO,CAAChP,IAAM4M,GACzC,IAGIkC,SAAAA,EAAeM,EAAmBG,GACnCC,IAAAA,EAAuB,UAATD,EACdE,EAASD,GAAetE,EAAcA,EACtCwE,EAAclB,EAAamB,gBAAgBF,GAE1CL,OAAAA,EAAQ/Q,IAAI,SAAAkI,GACXqJ,IAAAA,EAAUJ,EAAc,GAAKtE,EAC7B2E,EAAUL,EAActE,EAAc,EAEtC5C,EADSoH,EAAYrN,OAAO,SAAAyN,GAAKA,OAAAA,EAAEvJ,QAAUA,IAAO,GACrCiJ,EAAc,MAAQ,SAGpC,MAAA,CAAElH,MAAK,EAAEyH,UAFE,WAChBxB,OAAAA,EAAejN,MAAQgH,EAAQsH,EAAUC,GAChBtJ,MAAK,EAAElD,UAAW,KA8C1CvG,MANmB,CACxBkT,QAzBOA,WACAnB,OAAAA,EAAWoB,MAAM,SAAChS,GAAEsI,IAAAA,EAAK,EAAA,MAEvB4I,OAAAA,EADcT,EAASrM,OAAO,SAAArC,GAAKA,OAAAA,IAAMuG,IACVhK,IAAa,KAuBrD2T,MAROA,SAAMC,GACbtB,EAAW3C,QAAQ,SAACjO,GAAEsI,IAAAA,EAAK,EAAA,MACzB4J,EAAO5J,GAAO6J,MAAMlB,GAAa,MAOnCjO,KApBOA,SAAKkP,GACZtB,EAAW3C,QAAQ,SAAAmE,GACTN,IAAAA,EAA+BM,EAAS,UAA7BhN,EAAoBgN,EAAS,SAAnB9J,EAAU8J,EAAS,MAC1CvN,EAASiN,IACXjN,IAAWO,IACb8M,EAAO5J,GAAO6J,MAAMlB,GAAgBvN,EAAUC,QAAQkB,GAAlB,IACpCuN,EAAUhN,SAAWP,MAezB+L,WAAU,GChGEyB,SAAAA,EAAWhU,GACjB4G,IAAAA,EAAmC5G,EAAM,SAA/BiU,EAAyBjU,EAAM,eAAf6G,EAAS7G,EAAM,KAC3CkU,EAAa3O,IACbsF,EAAkBqJ,EAAWpO,UAC/BqO,EAAmB,EAEdC,SAAAA,EAAiBC,GACiB,IAApCA,EAAwBC,UAC7BH,GAAmB,IAAIvI,MAAOC,WAGvB0I,SAAAA,EAAcC,EAAoBvK,GAUzCiK,EAAW1P,IAAIgQ,EAAO,QATR,WAGRtI,MAFY,IAAIN,MAAOC,UACAsI,EACZ,IAAXjI,CAEJrF,EAAK4N,WAAa,EACZC,IAAAA,EAAgBpS,KAAKqS,MAAM1K,EAAQgK,GACzCrN,EAASqD,MAAMyK,EAAe,MAEM,GAYjClU,MAJkB,CACvBmK,oBANOA,SAAoBkJ,GAC3BK,EAAW1P,IAAIyE,SAAU,UAAWmL,GAAkB,GACtDP,EAAOjE,QAAQ2E,IAKf1J,gBAAe,GCxBH+J,SAAAA,EAAa5U,GACnB4O,IAAAA,EAAsC5O,EAAM,YAA/BmS,EAAyBnS,EAAM,WAAnBC,EAAaD,EAAM,SAC5C6U,EAA0B7U,EAAM,gBAAf2E,EAAS3E,EAAM,KAClC8U,EAAYxS,KAAKsC,IAAItC,KAAKuC,IAAIgQ,EAAiB,KAAO,KACtD7F,EAAclL,EAAUqO,GAAYpQ,IAMjCqP,SAAWnH,GAEX8K,OADM5C,EAAWtO,MAAM,EAAGoG,GACrBoG,OAAO,SAACC,EAAGC,GAAMD,OAAAA,EAAIC,GAAG,KANhC6C,GADUzO,EAAO,CAAC,EAAGiK,GAAcA,GAAe,CAAC,IAC7ByB,OAAO,SAACC,EAAiB0E,GAC5C1E,OAAAA,EAAEoC,OAAOW,EAAgB2B,EAAYF,KAC3C,IAOMzB,SAAAA,EAAgBF,EAAgB2B,GACjCG,IAAAA,EAAa9C,EAAWpQ,IAAI,SAAAwO,GAAKA,OAAAA,GAAKuE,GAAa,KAClD9F,OAAAA,EAAYjN,IAAI,SAACkP,EAAMhH,GAAW,MAAA,CACvC7J,MAAO6Q,EAAOkB,EAAWlI,GAASgL,EAAWhL,GAASkJ,EACtD5S,IAAK0Q,EAAOhR,EAAWgV,EAAWhL,GAASkJ,EAC3ClJ,MAAK,KAiBFzJ,MAJoB,CACzB0U,MAVOA,SAAMnO,GACNqM,OAAAA,EAAY/C,OAAO,SAAC8E,EAAgBC,GACjCnL,IAAAA,EAAsBmL,EAAU,MAAzBhV,EAAegV,EAAU,MAAlB7U,EAAQ6U,EAAU,IAGjC,OAFiC,IAAzBD,EAAKxM,QAAQsB,IACb7J,EAAQ2G,GAAYxG,EAAMwG,EACdoO,EAAKzC,OAAO,CAACzI,IAAUkL,GACjD,KAKH9B,gBAAe,GCvCHgC,SAAAA,EAAUrV,GAChBuB,IAAAA,EAA+BvB,EAAM,KAA/BsV,EAAyBtV,EAAM,UAApBqF,EAAcrF,EAAM,UACvCuV,EAAiBD,EAAUxB,MAC3B0B,EAA4B,MAAhBjU,EAAKC,OAMdyJ,SAAE3K,GACF,MAAA,eAAeA,EAAf,cAGA4K,SAAE5K,GACF,MAAA,mBAAmBA,EAAnB,UAVH4M,EAAqBrK,EAAgB,GAEvCwL,GAAW,EACXtH,EAAW,EAiCRvG,MALiB,CACtBoT,MANOA,WACP2B,EAAeE,UAAY,GAC3B1O,EAAW,GAKX2O,GApBOA,SAAG/H,GACJnH,IAAAA,EAAS0G,EAAmBS,EAAE3I,OAChCqJ,GAAYtH,IAAaP,IAE7BmP,iBAAiBL,GAAWG,UAC5BF,EAAeE,UAAYD,EAAUnQ,EAAUC,QAAQkB,IACvDO,EAAWP,IAeXiI,aAZOA,SAAa1N,GACpBsN,GAAYtN,ICSA6U,SAAAA,EACd/O,EACAyO,EACAzB,EACAlO,EACAqB,GAIE9G,IAAAA,EAUEyF,EAAO,MATHsB,EASJtB,EAAO,KAREkQ,EAQTlQ,EAAO,UAPTmQ,EAOEnQ,EAAO,WANTkP,EAMElP,EAAO,gBALThB,EAKEgB,EAAO,KAJT4H,EAIE5H,EAAO,MAHTe,EAGEf,EAAO,SAFTsO,EAEEtO,EAAO,eADToQ,EACEpQ,EAAO,cAGLpE,EAAOD,EAAK2F,GACZ8D,EAAc8B,EAAYtL,EAAKd,QAAQ6U,IACvCrV,EAAW8K,EAAYgC,aACvBoF,EAAa0B,EAAO9R,IAAIR,EAAKd,SAASsB,IAAIgJ,EAAYtK,SACtDuV,EAAelS,EAAUqO,GAEzBlC,EADe3M,EAAW6O,EAAY8B,GACblS,IAAI,SAAAkU,GAAKA,OAAAA,EAAE5F,OAAO,SAACC,EAAGC,GAAMD,OAAAA,EAAIC,MACzD3B,EAAcuD,EAAW9B,OAAO,SAACC,EAAGC,GAAMD,OAAAA,EAAIC,GAAG,GACjD5B,EAAY5O,EAAU,CAAEG,MAAK,EAAED,SAAQ,IACvCmR,EAAapB,EAAW,CAAEC,UAAS,EAAEtB,UAAS,EAAEhK,KAAI,IACpDuR,EAAepS,EAAUmM,GAAWlO,IAAIqP,EAAW3Q,SACnD0V,EAAUzH,EAAc,CAAEC,UAAS,EAAEC,YAAW,EAAE3O,SAAQ,IAC1DmW,GAAiBzR,GAA0B,KAAlBoR,EACzBM,EAA8B,cAAlBN,EACZ7G,EAAiBiH,EAAQ1V,QAAQyV,EAAcG,GAC/CrH,GAAcoH,EAAgBlH,EAAiBgH,EAE/CxR,GADc6K,EAAY,CAAE5K,KAAI,EAAEiK,YAAW,IACzBnO,QAAQuO,IAC5B3J,GAAYD,EAAUyQ,GAKtB5L,GAAQxF,EAAQ,CAAEC,MADN8H,EAAM,CAAE5H,IAAK,EAAGC,IADjBvC,KAAKuC,IAAI,EAAGmK,GAAYrL,OAAS,KAERvD,MAAO0V,EAAYnR,KAAI,IAC3D+M,GAAgBzH,GAAM9E,QA2BtBwB,GAAYhG,EAxBH,WACRgE,GACH2R,GAAOzH,aAAalC,UAAUnG,GAAQ8P,GAAOC,YAAY1N,eAE3DyN,GAAO7P,WAAWiH,KAAKlH,IAAQyH,SACzBuI,IAAAA,EAAUF,GAAO7P,WAAWsH,OAAOvH,IAErCgQ,IAAYF,GAAOC,YAAY1N,gBACjCyN,GAAO3P,UAAUvF,OACjB4F,EAAOqC,KAAK,WAETmN,GACHxP,EAAOqC,KAAK,UAEV1E,IACF2R,GAAOG,aAAa9R,KAAK+R,GAAaJ,GAAO7P,WAAWpB,aACxDiR,GAAOK,YAAYhS,KAAKkP,IAG1ByC,GAAOd,UAAUE,GAAG3O,IACpBuP,GAAO3P,UAAUxF,YAKbyV,GAAgB5H,GAAY/E,GAAMjF,OAClC+B,GAAWf,EAAS4Q,IACpBpQ,GAASR,EAAS4Q,IAClBF,GAAc,CAAC3P,GAAUP,IACzBC,GAAauG,EAAW,CAC5BjG,SAAQ,GACRwG,MAAK,EACLC,KAAM,IAEFxD,GAAewG,EAAa,CAChC5B,YAAW,EACX3E,MAAK,GACLvF,MAAK,GACLC,KAAI,EACJqK,YAAW,GACXxI,OAAM,KAEFI,GAAW4K,EAAS,CACxB7K,UAAS,GACTK,OAAM,EACNiD,MAAK,GACLyH,cAAa,GACb1H,aAAY,GACZxD,OAAM,KAEF0L,GAAe0C,EAAa,CAChChG,YAAW,EACXiG,gBAAe,EACflQ,KAAI,EACJwN,WAAU,EACVlS,SAAQ,IAyBJqW,GAAiB,CACrB3P,UAAS,GACTpF,KAAI,EACJ8D,UAAS,GACTkR,YAzBkBhQ,EAAY,CAC9BI,UAAS,GACTpF,KAAI,EACJ8D,UAAS,GACTqB,SAAQ,EACRI,YAAagE,EAAY,CACvBvJ,KAAI,EACJwJ,YAAW,IAEblE,KAAI,EACJG,OAAM,EACNiD,MAAK,GACLvF,MAAK,GACLqC,SAAQ,GACRN,WAAU,GACVG,SAAQ,GACRoD,aAAY,GACZxD,OAAM,KASNuE,YAAW,EACXd,MAAK,GACLyH,cAAa,GACbhN,MAAK,GACLqC,SAAQ,GACRpB,QAAO,EACPc,WAAU,GACVoI,aAAcV,EAAa,CACzBzJ,MAAK,GACLqC,SAAQ,GACRN,WAAU,KAEZgQ,aAAcjH,EAAa,CACzBZ,YAAW,EACXlK,MAAK,GACLqC,SAAQ,GACRgE,YAAW,IAEb8L,eAAgBhH,EAAe,CAC7BnL,MAAK,KAEPsK,YAAW,GACXhF,aAAY,GACZpD,SAAQ,GACRkQ,WAAY9C,EAAW,CACrBnN,KAAI,EACJD,SAAQ,GACRqN,eAAc,IAEhB0C,YAAa5E,EAAY,CACvBxQ,KAAI,EACJqN,YAAW,EACXvJ,UAAS,GACT0B,SAAQ,GACRiI,YAAW,GACXmD,WAAU,EACVD,aAAY,GACZjS,SAAQ,IAEViS,aAAY,GACZ8D,aAAY,EACZxP,OAAM,GACNgP,UAAWH,EAAU,CACnB9T,KAAI,EACJ+T,UAAS,EACTjQ,UAAS,MAGNiR,OAAAA,GCvNOS,SAAAA,IACRvR,IAAAA,EAAuB,GAEpBwR,SAAAA,EAAa5O,GAEb6O,OADgBzR,EAAU4C,IACR,GAkBrB5H,IAAAA,EAAqB,CACzB6I,KAhBOA,SAAKjB,GAEL5H,OADPwW,EAAa5O,GAAKwH,QAAQ,SAAAsH,GAAKA,OAAAA,EAAE9O,KAC1B5H,GAeP2W,IAPOA,SAAI/O,EAAiBpH,GAErBR,OADPgF,EAAU4C,GAAO4O,EAAa5O,GAAKrC,OAAO,SAAAmR,GAAKA,OAAAA,IAAMlW,IAC9CR,GAMP4W,GAbOA,SAAGhP,EAAiBpH,GAEpBR,OADPgF,EAAU4C,GAAO4O,EAAa5O,GAAKsK,OAAO,CAAC1R,IACpCR,IAaFA,OAAAA,E3BkMR,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,E4B3NM,IAAM6W,EAA0B,CACrCnX,MAAO,SACPqB,KAAM,IACNwU,cAAe,GACfuB,kBAAmB,IACnBjS,UAAW,MACXqB,UAAU,EACV6Q,WAAW,EACXC,eAAgB,eAChBC,cAAe,cACf5C,gBAAiB,EACjBlQ,MAAM,EACN+S,cAAe,cACfzD,eAAgB,EAChB1G,MAAO,GACPuI,WAAY,G5BVd,SAAS6B,EACPC,EACAC,GAEM7Q,IAMFsP,EAIAhB,EACAzB,EAXE7M,EAAS+P,IACT7C,EAAa3O,IACbuS,EAAkB7U,EA+Gf8U,WACH,IAACC,EAAW,OACVC,IAAAA,EAAqB3B,EAAO/U,KAAKd,QAAQmX,GAC3CM,IAAoBD,GAAoBE,IAC5CnR,EAAOqC,KAAK,WAnH2B,KACnC+O,EAASD,EACPf,EAAYpQ,EAAM,GAAdmQ,EAAQnQ,EAAM,IAGtBgR,GAAY,EACZrS,EAAU,EAAc,GAAI0R,GAC5Ba,EAAkB,EAkBbG,SAAAA,EAASC,GAQZ3S,GApBG4S,WACH,IAACX,EAAY,MAAM,IAAIY,MAAM,wBAE3BC,IAAAA,EAAW9S,EAAQ2R,kBACnBoB,EAAkBd,EAAWe,cAAcF,GAE7C,IAACC,EAAiB,MAAM,IAAIF,MAAM,6BAEtClD,EAAYoD,EACZ7E,EAAS+E,MAAMC,UAAUhV,MAAMiV,KAAKxD,EAAUyD,UAI9CR,GACA5S,EAAU,EAAcA,EAAS2S,GACjChC,EAASV,EAAOgC,EAAYtC,EAAWzB,EAAQlO,EAASqB,GACxDkR,EAAkB5B,EAAO/U,KAAKd,QAAQmX,GACtC1D,EAAW1P,IAAIvD,OAAQ,SAAU6W,GACjCxB,EAAOd,UAAUE,GAAGY,EAAOvP,UAEvBpB,EAAQhB,KAAM,CACZ,IAAC2R,EAAOK,YAAYjD,UAEf2E,OADPW,IACOX,EAAS,CAAE1T,MAAM,IAE1B2R,EAAOK,YAAYhS,KAAKkP,GAEtBlO,EAAQ4R,WAAa1D,EAAOlQ,SAC9B2S,EAAOC,YAAY5L,sBACfhF,EAAQ6R,gBACVjT,EAASqT,EAAYjS,EAAQ6R,gBAE3B7R,EAAQ8R,eACVzQ,EACGoQ,GAAG,cAAe6B,GAClB7B,GAAG,YAAa6B,IAGnBpF,EAAOlQ,QACT2S,EAAOQ,WAAWnM,oBAAoBkJ,GAEpClO,EAAQ+R,gBACVwB,IACAlS,EACGoQ,GAAG,SAAU8B,GACb9B,GAAG,YAAa8B,IAEhBlB,IACH3U,WAAW,WAAM2D,OAAAA,EAAOqC,KAAK,SAAS,GACtC2O,GAAY,GAIPiB,SAAAA,EAAoB7Q,GACnBqP,IAAAA,EAAkB9R,EAAO,cACrB,gBAARyC,EAAuB7D,EAASqT,EAAYH,GAC3CxT,EAAY2T,EAAYH,GAGtByB,SAAAA,IACCxB,IAAAA,EAAkB/R,EAAO,cAC3BwT,EAASjH,GAAa,GACVkH,GAAgB,GACxBxJ,QAAQ,SAAAlM,GAAKO,OAAAA,EAAY4P,EAAOnQ,GAAIgU,KAC9CyB,EAAOvJ,QAAQ,SAAAlM,GAAKa,OAAAA,EAASsP,EAAOnQ,GAAIgU,KAGjCsB,SAAAA,IACP1C,EAAOC,YAAY1L,kBACnByL,EAAOQ,WAAWjM,kBAClByL,EAAO3P,UAAUvF,OACjB8S,EAAWpO,YACXwQ,EAAOd,UAAU5B,QACjB0C,EAAOK,YAAY/C,MAAMC,GACzB5P,EAAY2T,EAAYjS,EAAQ6R,gBAChC3D,EAAOjE,QAAQ,SAAAW,GAAKtM,OAAAA,EAAYsM,EAAG5K,EAAQ+R,iBAC3C1Q,EAAOmQ,IAAI,SAAU+B,GACrBlS,EAAOmQ,IAAI,YAAa+B,GACxBlS,EAAOmQ,IAAI,cAAe8B,GAC1BjS,EAAOmQ,IAAI,YAAa8B,GAGjBd,SAAAA,EAAWG,GACd,GAACN,EAAD,CACElC,IACAuD,EAAa,EAAc,CAAEvD,WADhBwD,KAC8BhB,GACjDU,IACAX,EAASgB,GACTrS,EAAOqC,KAAK,WAiBL6I,SAAAA,EAAa1L,GACdO,IAAAA,EAAWuP,EAAO9P,EAAS,SAAW,YAAYxB,MAClDS,EAAOE,EAAQhB,KAAO,eAAiB,YACtC2R,OAAAA,EAAOpE,aAAagD,MAAMoB,EAAO5R,MAAMe,GAAMsB,IAG7CqS,SAAAA,EAAgB5S,GACjB2S,IAAAA,EAASjH,EAAa1L,GACrB8P,OAAAA,EAAON,aAAajQ,OAAO,SAAArC,GAAKyV,OAAuB,IAAvBA,EAAOxQ,QAAQjF,KAG/CkD,SAAAA,EAASqD,EAAe5E,GAC/BiR,EAAO7P,WAAWqC,cAAcoF,eAC5B8J,GAAW1B,EAAO1P,SAASqD,MAAMA,EAAO5E,GAAa,GA+BlDiU,SAAAA,IACAhD,OAAAA,EAAOrM,MAAMjF,MA4CfxE,OApMP6X,EAASR,GA+KmB,CAC1B0B,cA3COA,WAEAjP,OADMgM,EAAOrM,MAAM9E,QAAQX,IAAI,GAC1BQ,QAAUsU,KA0CtBE,cAvCOA,WAEAC,OADMnD,EAAOrM,MAAM9E,QAAQX,KAAK,GAC3BQ,QAAUsU,KAsCtB1O,aAnBOA,WACA0L,OAAAA,EAAOC,YAAY3L,gBAmB1B8O,cAZOA,WACApE,OAAAA,GAYPqE,qBAjBOA,WACArD,OAAAA,GAiBPsD,QAxFOA,WACF5B,IACLgB,IACAhB,GAAY,EACZhR,EAAOqC,KAAK,aAqFZ8N,IAAG,EACHC,GAAE,EACFyC,mBA7BOA,WACAvD,OAAAA,EAAO5E,cAAc1M,OA6B5BoT,OAAM,EACN0B,WA/DOA,WAEPlT,EADa0P,EAAOrM,MAAM9E,QAAQX,IAAI,GACxBQ,OAAQ,IA8DtB+U,WA3DOA,WAEPnT,EADa0P,EAAOrM,MAAM9E,QAAQX,KAAK,GACzBQ,MAAO,IA0DrB6R,eAzCOA,WACAP,OAAAA,EAAOO,eAAe7R,IAAIsR,EAAOvP,SAAS/B,QAyCjDgV,eA9COA,WACA1D,OAAAA,EAAOtH,YAAYjN,IAAIuU,EAAOO,eAAe7R,MA8CpD4B,SAAQ,EACR0S,mBAAkB,EAClBW,WArBOA,WACApG,OAAAA,GAqBP3B,aAAY,EACZkH,gBAAe,GAGlB,IAAA,EAAA,EAAA,QAAA,QAAA;;C6BlPD,WACA,IAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,SAAA,EAAA,GAAA,OAAA,WAAA,OAAA,EAAA,MAAA,EAAA,aACA,EAAA,GAAA,SAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,KAAA,OAAA,EAAA,EAAA,IAAA,GAAA,KAAA,MAAA,KAAA,KAAA,EAAA,OAAA,EAAA,OAAA,GAEA,EAAA,WACA,SAAA,KA8EA,OA5EA,EAAA,UAAA,OAAA,SAAA,EAAA,GACA,IAAA,EAAA,EACA,IAAA,KAAA,EACA,EAAA,EAAA,GACA,MAAA,EAAA,KACA,EAAA,GAAA,GAGA,OAAA,GAGA,EAAA,UAAA,SAAA,SAAA,GACA,MAAA,iEAAA,KAAA,IAGA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAmBA,OAlBA,MAAA,IACA,GAAA,GAEA,MAAA,IACA,GAAA,GAEA,MAAA,IACA,EAAA,MAEA,MAAA,SAAA,aACA,EAAA,SAAA,YAAA,gBACA,gBAAA,EAAA,EAAA,EAAA,GACA,MAAA,SAAA,mBACA,EAAA,SAAA,qBACA,UAAA,EAEA,EAAA,UAAA,EAEA,GAGA,EAAA,UAAA,UAAA,SAAA,EAAA,GACA,OAAA,MAAA,EAAA,cACA,EAAA,cAAA,GACA,KAAA,MAAA,GACA,EAAA,KACA,KAAA,KAAA,MAAA,GACA,EAAA,KAAA,UADA,GAKA,EAAA,UAAA,SAAA,SAAA,EAAA,EAAA,GACA,OAAA,MAAA,EAAA,iBACA,EAAA,iBAAA,EAAA,GAAA,GACA,MAAA,EAAA,YACA,EAAA,YAAA,KAAA,EAAA,GAEA,EAAA,GAAA,GAIA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,GACA,OAAA,MAAA,EAAA,oBACA,EAAA,oBAAA,EAAA,GAAA,GACA,MAAA,EAAA,YACA,EAAA,YAAA,KAAA,EAAA,UAEA,EAAA,IAIA,EAAA,UAAA,YAAA,WACA,MAAA,gBAAA,OACA,OAAA,YAEA,SAAA,gBAAA,cAIA,EA/EA,GAmFA,EAAA,KAAA,SAAA,KAAA,aAAA,EAAA,WACA,SAAA,IACA,KAAA,KAAA,GACA,KAAA,OAAA,GA4BA,OAzBA,EAAA,UAAA,IAAA,SAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAEA,IAAA,EAAA,EAAA,EAAA,GADA,EAAA,KAAA,MACA,OAAA,EAAA,EAAA,IAAA,EAEA,GADA,EAAA,KACA,EACA,OAAA,KAAA,OAAA,IAKA,EAAA,UAAA,IAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAEA,IAAA,EAAA,EAAA,EAAA,GADA,EAAA,KAAA,MACA,OAAA,EAAA,EAAA,IAAA,EAEA,GADA,EAAA,KACA,EAEA,YADA,KAAA,OAAA,GAAA,GAKA,OADA,KAAA,KAAA,KAAA,GACA,KAAA,OAAA,KAAA,IAGA,EA/BA,IAmCA,EAAA,KAAA,kBAAA,KAAA,wBAAA,KAAA,sBAAA,EAAA,WACA,SAAA,IACA,oBAAA,SAAA,OAAA,SACA,QAAA,KAAA,sDAEA,oBAAA,SAAA,OAAA,SACA,QAAA,KAAA,sFAQA,OAJA,EAAA,cAAA,EAEA,EAAA,UAAA,QAAA,aAEA,EAdA,IAkBA,EAAA,KAAA,kBAAA,SAAA,EAAA,GAaA,OAZA,KAAA,iBAAA,SAAA,GACA,IAAA,EASA,MARA,UAAA,IACA,EAAA,cAEA,EAAA,KAAA,IACA,EAAA,QAAA,EAAA,SAAA,EAAA,GACA,OAAA,EAAA,iBAGA,OAAA,EAAA,EAAA,cAAA,EAAA,QAAA,IAAA,MAEA,MAGA,EAAA,kBAEA,KAAA,IAAA,WAWA,SAAA,EAAA,GACA,MAAA,IACA,EAAA,IAEA,KAAA,eAAA,EAAA,KAAA,eAAA,MACA,KAAA,cAAA,EAAA,KAAA,cAAA,MACA,KAAA,eAAA,EAAA,KAAA,eAAA,MACA,KAAA,MAAA,EAAA,KAAA,MAAA,MACA,KAAA,UAAA,EACA,KAAA,OAAA,KAAA,OAAA,OAAA,EAAA,KAAA,UACA,MAAA,EAAA,kBACA,KAAA,OAAA,gBAAA,SAAA,cAAA,EAAA,kBAEA,KAAA,mBAAA,IAAA,EACA,KAAA,SAAA,KAAA,OAAA,YAAA,KAAA,OAAA,UAoUA,OA5VA,EAAA,UAAA,SAAA,CACA,SAAA,MACA,aAAA,WACA,OAAA,EACA,QAAA,EACA,MAAA,EACA,SAAA,KACA,gBAAA,MAoBA,EAAA,UAAA,KAAA,WACA,IAAA,EAOA,OANA,KAAA,QAAA,OAAA,SAAA,gBACA,iBAAA,EAAA,SAAA,aAAA,aAAA,EACA,KAAA,QAEA,KAAA,OAAA,SAAA,SAAA,mBAAA,KAAA,OAEA,KAAA,SAAA,IAGA,EAAA,UAAA,MAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAuCA,EAjBA,GArBA,KAAA,SAAA,EACA,KAAA,MAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,KAAA,QAAA,iBAAA,IAAA,KAAA,OAAA,WAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,GAEA,OAAA,GACA,KAAA,MACA,KAAA,IAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,KAAA,OAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,GAEA,OAAA,GACA,KAAA,MACA,KAAA,MAAA,OACA,GAAA,KAAA,WACA,KAAA,kBAGA,IAAA,EAAA,EAAA,GADA,EAAA,KAAA,OACA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,KAAA,WAAA,GAAA,GASA,GALA,KAAA,aACA,KAAA,OAAA,SAAA,KAAA,OAAA,iBAAA,OAAA,SAAA,KAAA,eACA,KAAA,OAAA,SAAA,OAAA,SAAA,KAAA,eACA,KAAA,SAAA,YAAA,KAAA,eAAA,KAEA,KAAA,OAAA,KACA,OAAA,IAAA,GAAA,EAmBA,KAlBA,SAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAEA,IADA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,EAAA,YAAA,IAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,KAAA,OAAA,IAEA,OAAA,GACA,KAAA,IAEA,OAAA,KAEA,QAAA,SAAA,KAAA,CACA,WAAA,EACA,SAAA,KAKA,EAAA,UAAA,KAAA,WAIA,GAHA,KAAA,SAAA,EACA,KAAA,OAAA,YAAA,KAAA,OAAA,iBAAA,OAAA,SAAA,KAAA,eACA,KAAA,OAAA,YAAA,OAAA,SAAA,KAAA,eACA,MAAA,KAAA,SACA,OAAA,cAAA,KAAA,WAIA,EAAA,UAAA,KAAA,SAAA,GACA,GAAA,EAAA,aACA,OAAA,KAAA,OAAA,KAAA,UAIA,EAAA,UAAA,OAAA,SAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAIA,GAHA,MAAA,IACA,EAAA,KAAA,SAEA,IAAA,EAAA,SAAA,CAMA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,GADA,EAAA,EAAA,YAAA,GACA,iBAAA,IAAA,KAAA,OAAA,WAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,KAAA,IAAA,GAAA,GACA,KAAA,MAAA,KAAA,GACA,KAAA,IAAA,KAAA,GACA,KAAA,SAAA,KAAA,WACA,KAAA,aAEA,KAAA,WAAA,GAAA,GAEA,EAAA,KAAA,KAAA,UAAA,IAEA,EAAA,UAAA,GAGA,OAAA,IAGA,EAAA,UAAA,KAAA,SAAA,GAWA,OAVA,KAAA,WAAA,GACA,EAAA,UAAA,EAAA,UAAA,IAAA,KAAA,OAAA,aACA,MAAA,KAAA,OAAA,UACA,KAAA,OAAA,SAAA,GAEA,KAAA,OAAA,UAAA,EAAA,KAAA,UACA,KAAA,OAAA,SAAA,EAAA,eAAA,KAAA,gBACA,KAAA,OAAA,SAAA,EAAA,gBAAA,KAAA,gBACA,KAAA,OAAA,SAAA,EAAA,qBAAA,KAAA,gBACA,KAAA,OAAA,SAAA,EAAA,iBAAA,KAAA,gBACA,GAGA,EAAA,UAAA,WAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAIA,EAAA,OAHA,EAAA,EAAA,aAAA,qBACA,EAAA,EAAA,aAAA,kBACA,EAAA,EAAA,aAAA,sBACA,KAAA,SAAA,EAIA,KAHA,WACA,OAAA,EAAA,YAAA,EAAA,EAAA,EAAA,EAAA,OAKA,EAAA,UAAA,QACA,0BAAA,OACA,SAAA,GACA,OAAA,OAAA,sBAAA,IAGA,SAAA,GACA,OAAA,KAKA,EAAA,UAAA,WAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,KAAA,OAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,MAAA,WAAA,WAEA,OAAA,GAGA,EAAA,UAAA,eAAA,SAAA,GACA,IAAA,EACA,GAAA,EAAA,KAAA,cAAA,QAAA,iBAAA,EAEA,OADA,EAAA,EAAA,QAAA,EAAA,YACA,UAAA,EAAA,UAAA,QAAA,KAAA,OAAA,aAAA,IAAA,QAIA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAuBA,OAtBA,GACA,KAAA,mBAAA,GAEA,EAAA,MAAA,WAAA,EAAA,SAAA,UACA,GACA,KAAA,UAAA,EAAA,MAAA,CACA,kBAAA,IAGA,GACA,KAAA,UAAA,EAAA,MAAA,CACA,eAAA,IAGA,GACA,KAAA,UAAA,EAAA,MAAA,CACA,wBAAA,IAGA,KAAA,UAAA,EAAA,MAAA,CACA,cAAA,EAAA,OAAA,KAAA,oBAAA,KAEA,GAGA,EAAA,UAAA,QAAA,CAAA,MAAA,UAEA,EAAA,UAAA,UAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAEA,IAAA,KADA,EAAA,GACA,EACA,EAAA,EAAA,GACA,EAAA,GAAA,GAAA,EACA,EAAA,KAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,KAAA,SAEA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,OAAA,GAAA,cAAA,EAAA,OAAA,IAAA,GAEA,OAAA,GACA,KAAA,OAEA,OAAA,GAGA,EAAA,UAAA,UAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAIA,IAFA,GADA,EAAA,EAAA,IACA,oBAAA,GAEA,EAAA,EAAA,GADA,EAAA,KAAA,SACA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,oBAAA,IAAA,EAAA,IAAA,GAEA,OAAA,GAGA,EAAA,UAAA,cAAA,SAAA,GACA,IAAA,EACA,IACA,EAAA,KAAA,UAAA,EAAA,kBAAA,QACA,MAAA,GACA,EAAA,EAAA,GAAA,iBAAA,kBAEA,MAAA,SAAA,EACA,GAEA,GAIA,EAAA,UAAA,mBAAA,SAAA,GACA,OAAA,KAAA,mBAAA,IAAA,EAAA,KAAA,cAAA,KAGA,EAAA,UAAA,oBAAA,SAAA,GACA,OAAA,KAAA,mBAAA,IAAA,IAGA,EAAA,UAAA,cAAA,WACA,OAAA,KAAA,UAAA,GAGA,EAAA,UAAA,eAAA,WACA,IAAA,EACA,GAAA,KAAA,WACA,KAAA,UAAA,EACA,KAAA,MAAA,WACA,IAAA,EAAA,EAAA,EAAA,EAGA,IADA,EAAA,GACA,EAAA,EAAA,GAFA,EAAA,KAAA,OAEA,OAAA,EAAA,EAAA,KACA,EAAA,EAAA,MAIA,KAAA,UAAA,GACA,KAAA,KAAA,GAGA,EAAA,KAAA,IAEA,OAAA,GACA,KAAA,OACA,KAAA,MAAA,SAAA,KAAA,OAAA,MACA,OAAA,KAAA,QAKA,EAAA,UAAA,UAAA,SAAA,GAEA,IADA,IAAA,OACA,IAAA,EAAA,WACA,EAAA,EAAA,WAGA,IADA,EAAA,EAAA,UACA,EAAA,EAAA,cACA,GAAA,EAAA,UAEA,OAAA,GAGA,EAAA,UAAA,UAAA,SAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EAMA,OALA,EAAA,EAAA,aAAA,oBAAA,KAAA,OAAA,OAEA,GADA,EAAA,KAAA,OAAA,iBAAA,KAAA,OAAA,gBAAA,WAAA,OAAA,aACA,KAAA,IAAA,KAAA,QAAA,aAAA,KAAA,OAAA,eAAA,EAEA,GADA,EAAA,KAAA,UAAA,IACA,EAAA,aACA,GAAA,GAAA,GAAA,GAGA,EAAA,UAAA,KAAA,WACA,OAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,IAAA,GAGA,EAAA,UAAA,SAAA,WACA,OAAA,KAAA,OAAA,QAAA,KAAA,OAAA,SAAA,UAAA,YAGA,EA7VA,KAiWA,KAAA;;AC3TA,aA/JA,IAAA,EAAA,EAAA,QAAA,mBA+JA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GApLA,IAAIc,EAAYjR,SAASkR,iBAAiB,eAC1CD,EAAUtK,QAAQ,SAASwK,GACnBC,IACAC,EAAQ,OADAF,EAAGrB,SAAS,GAAGwB,IACE,IAC7BH,EAAGI,WAAW1G,MAAd,gBAAyCwG,EACzCF,EAAGI,WAAWpW,UAAUI,IAAI,cAC5B4V,EAAG9V,WAMPrD,OAAO2E,iBAAiB,SAAU,WAC3B3E,OAAOwZ,QAAU,IAChBxR,SAAS0P,cAAc,kBAAkBvU,UAAUI,IAAI,gBAEvDyE,SAAS0P,cAAc,kBAAkBvU,UAAUE,OAAO,kBAMlE,IAAMoW,EAAOzR,SAAS0P,cAAc,UAC9BgC,EAAWD,EAAK/B,cAAc,oBAC9BiC,EAAUF,EAAK/B,cAAc,wBAC7BkC,EAAUH,EAAK/B,cAAc,wBAC7BmC,GAAQ,EAAcH,EAAAA,SAAAA,EAAU,CAClC1G,eAAgB,EAChBtP,MAAM,EACNoR,cAAe,cAEbgF,EAAyBC,oBAAoBJ,EAASC,EAASC,GAwDrE,SAASlU,IAASqU,IAAAA,EAAUhS,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAAA,SAASiS,gBAAiBxF,EAAK,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAAGyF,EAAW,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,IACjE/a,EAAQ6a,EAAQG,UAChBC,EAAS3F,EAAKtV,EACdkb,EAAc,GAGE,SAAhBC,IACAD,GAHY,GAIRE,IAAAA,EAAMlZ,KAAKmZ,cAAcH,EAAalb,EAAOib,EAAQF,GACzDF,EAAQG,UAAYI,EACjBF,EAAcH,GACb9X,WAAWkY,EAPH,IAUhBA,GApEJG,kBAAkBd,EAASC,EAASC,GAEpCA,EAAM1D,GAAG,SAAU2D,GACnBD,EAAM1D,GAAG,OAAQ2D,GA2Bb9R,SAAS0P,cAAc,iBACvB1X,OAAO2E,iBAAiB,SAAU,WAC9BqD,SAASkR,iBAAiB,WAAWvK,QAAQ,SAAUwK,GAC/CuB,IAAAA,EAAYvB,EAAGwB,aAAa,MAC5BC,EAAazB,EAAG0B,UAAY,IAC5BC,EAAe3B,EAAG4B,aAClBC,EAAUhb,OAAOwZ,QAEjByB,EADUjT,SAAS0P,cAAc,YAAcgD,EAAY,MAC7CnB,WACdyB,GAAAA,EAAUJ,EAAa,GAAKI,EAAUJ,EAAaE,EAAe,EAAG,CACrEG,EAAI9X,UAAUI,IAAI,UACd2X,IAAAA,EAAMD,EAAI1B,WAAWzB,SACtBlV,GAAAA,MAAMiV,KAAKqD,GAAKvM,QAAQ,SAACwK,GACrBA,GAAM8B,GACL9B,EAAGhW,UAAUE,OAAO,iBA2B5ChC,KAAKmZ,cAAgB,SAAUW,EAAG5I,EAAGzH,EAAGsQ,GAEhCD,OADJA,GAAKC,EAAE,GACC,EAAUtQ,EAAE,EAAEqQ,EAAEA,EAAI5I,GAEpBzH,EAAE,KADVqQ,GACkBA,EAAE,GAAK,GAAK5I,GAGlCvK,SAASkR,iBAAiB,uBAAuBvK,QAAQ,SAACU,GACtDA,EAAE1K,iBAAiB,QAAS,SAACyO,GACrB7N,IAAAA,EAASyC,SAAS0P,cAAcrI,EAAEsL,aAAa,SAC/CO,EAAM7L,EAAEkK,WAAWA,WAAWzB,SAC/BlV,GAAAA,MAAMiV,KAAKqD,GAAKvM,QAAQ,SAACwK,GACpBA,EAAGhW,UAAUE,OAAO,YAE5BgM,EAAEkK,WAAWA,WAAWpW,UAAUI,IAAI,UAElCgC,IACA6N,EAAMzL,iBACNhC,EAASqC,SAASiS,gBAAiB1U,EAAOsV,UAAY,IAAK,MAK3D7S,SAAS0P,cAAc,oBAAoBvU,UAAUC,SAAS,UAC9D4E,SAAS0P,cAAc,oBAAoBvU,UAAUkY,OAAO,QAC5DrT,SAAS0P,cAAc,wBAAwBvU,UAAUkY,OAAO,UAChErT,SAAS0P,cAAc,mBAAmBvU,UAAUkY,OAAO,kBAQvErT,SAAS0P,cAAc,mBAAmB/S,iBAAiB,QAAS,SAACwC,GACjEA,EAAImU,cAAcnY,UAAUkY,OAAO,aACnCrT,SAAS0P,cAAc,wBAAwBvU,UAAUkY,OAAO,UAChErT,SAAS0P,cAAc,kBAAkBvU,UAAUkY,OAAO,UAM9D,IAAIE,EAAMC,QAAQ,SAASD,IACvBE,EAAM,IAAIF,EAAI,CACdG,SAAU,MACVC,aAAc,WACdzJ,OAAQ,GACR0J,QAAQ,EACRC,MAAM,IAGVJ,EAAIK,OAGJ9T,SAAS0P,cAAc,oBAAoB/S,iBAAiB,SAAU,SAACsR,GACnEA,EAAEtO,iBACEoU,IAAAA,EAAO9F,EAAEqF,cACTU,EAAM,IAAIC,eAEdD,EAAIE,KAAK,MAAO,IAAI,GAEpBF,EAAIG,mBAAqB,WAEjB,GADJnU,SAAS0P,cAAc,gBAAgBvU,UAAUI,IAAI,UACjD,KAAK6Y,aAAeH,eAAeI,KAAM,CACzCC,QAAQC,IAAI,iBAAmB,KAAKC,QAChCC,IAAAA,EAAOzU,SAAS0P,cAA8B,MAAhB,KAAK8E,OAAiB,kBAAoB,iBAC5EC,EAAKtZ,UAAUE,OAAO,UACtBoZ,EAAK5J,MAAL,WAA2B,UAC3B4J,EAAK5J,MAAM,kBAAoB,aAIvCmJ,EAAIU,KAAK,IAAIC,SAASZ,MAG1B/T,SAAS0P,cAAc,aAAa/S,iBAAiB,QAAS,WAC1DqD,SAAS0P,cAAc,gBAAgBvU,UAAUE,OAAO,UACxD2E,SAAS0P,cAAc,iBAAiBvU,UAAUI,IAAI;;ACzL1D,aATA,SAASqZ,EAAU3G,GACX4G,IAAAA,EAAO5G,EAAEqF,cACbtT,SAASkR,iBAAiB,eAAevK,QAAS,SAACwK,GAC5CA,GAAM0D,GACL1D,EAAGhW,UAAUE,OAAO,YAE5BwZ,EAAK1Z,UAAUkY,OAAO,UAX1B,QAAA,oBAGA,QAAA,kBAWArT,SAASkR,iBAAiB,QAAQvK,QAAQ,SAACmO,GACvCA,EAAInY,iBAAiB,QAASiY","file":"main.2956227f.js","sourceRoot":"..","sourcesContent":["import { Engine } from './components/engine'\nimport { EventEmitter, EmblaEvent } from './components/eventEmitter'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptions } from './components/options'\nimport { addClass, debounce, removeClass } from './components/utils'\n\nexport type EmblaCarousel = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitter['off']\n  on: EventEmitter['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptions) => void\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions?: EmblaOptions,\n): EmblaCarousel {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let rootElementSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function storeElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node 😢')\n\n    const selector = options.containerSelector\n    const sliderContainer = sliderRoot.querySelector(selector)\n\n    if (!sliderContainer) throw new Error('Missing container node 😢')\n\n    container = sliderContainer as HTMLElement\n    slides = Array.prototype.slice.call(container.children)\n  }\n\n  function activate(partialOptions?: EmblaOptions): void {\n    storeElements()\n    options = Object.assign(options, partialOptions)\n    engine = Engine(sliderRoot, container, slides, options, events)\n    rootElementSize = engine.axis.measure(sliderRoot)\n    eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false })\n      }\n      engine.slideLooper.loop(slides)\n    }\n    if (options.draggable && slides.length) {\n      engine.dragHandler.addActivationEvents()\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass)\n      }\n      if (options.draggingClass) {\n        events\n          .on('pointerDown', toggleDraggingClass)\n          .on('pointerUp', toggleDraggingClass)\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides)\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass()\n      events\n        .on('select', toggleSelectedClass)\n        .on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEvent): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach(i => removeClass(slides[i], selectedClass))\n    inView.forEach(i => addClass(slides[i], selectedClass))\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.slideFocus.removeAllEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach(s => removeClass(s, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function reActivate(partialOptions?: EmblaOptions): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const newRootElementSize = engine.axis.measure(sliderRoot)\n    if (rootElementSize !== newRootElementSize) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter(i => inView.indexOf(i) === -1)\n  }\n\n  function scrollTo(index: number, direction?: number): void {\n    engine.scrollBody.useBaseMass().useBaseSpeed()\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarousel = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","export type AlignmentOption = 'start' | 'center' | 'end' | number\n\ntype Params = {\n  viewSize: number\n  align: AlignmentOption\n}\n\nexport type Alignment = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(params: Params): Alignment {\n  const { viewSize, align } = params\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: Alignment = {\n    measure,\n  }\n  return self\n}\n","type Callback = () => void\n\nexport type Animation = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): Animation {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: Callback): Callback {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: Animation = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","export type AxisOption = 'x' | 'y'\n\nexport type Axis = {\n  cross: AxisOption\n  scroll: AxisOption\n  measure: (node: HTMLElement) => number\n}\n\nexport function Axis(axis: AxisOption): Axis {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n\n  function measure(node: HTMLElement): number {\n    const { width, height } = node.getBoundingClientRect()\n    return scroll === 'x' ? width : height\n  }\n\n  const self: Axis = {\n    cross,\n    measure,\n    scroll,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / Math.abs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return Math.abs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0\n  const diff = deltaAbs(Math.abs(valueB), Math.abs(valueA))\n  return Math.abs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  let timeout = 0\n  return (): void => {\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function removeClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && !cl.contains(className)) cl.add(className)\n}\n","import { Limit } from './limit'\nimport { mathSign } from './utils'\n\ntype Params = {\n  start: number\n  limit: Limit\n  loop: boolean\n}\n\nexport type Counter = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => Counter\n  add: (n: number) => Counter\n  clone: () => Counter\n}\n\nexport function Counter(params: Params): Counter {\n  const { start, limit, loop } = params\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): Counter {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): Counter {\n    if (n !== 0) {\n      const sign = mathSign(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): Counter {\n    return Counter({ start: get(), limit, loop })\n  }\n\n  const self: Counter = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","export type DirectionOption = 'ltr' | 'rtl'\n\nexport type Direction = {\n  applyTo: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOption): Direction {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function applyTo(n: number): number {\n    return n * sign\n  }\n\n  const self: Direction = {\n    applyTo,\n  }\n  return self\n}\n","type EventRemover = () => void\ntype EventHandler = EventListener | EventListenerObject | null\ntype EventOptions = boolean | AddEventListenerOptions | undefined\n\nexport type EventStore = {\n  add: (\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options?: EventOptions,\n  ) => EventStore\n  removeAll: () => EventStore\n}\n\nexport function EventStore(): EventStore {\n  let listeners: EventRemover[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options: EventOptions = false,\n  ): EventStore {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStore {\n    listeners = listeners.filter(remove => remove())\n    return self\n  }\n\n  const self: EventStore = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","export type Vector1D = {\n  get: () => number\n  set: (v: Vector1D | number) => Vector1D\n  add: (v: Vector1D | number) => Vector1D\n  subtract: (v: Vector1D | number) => Vector1D\n  multiply: (n: number) => Vector1D\n  divide: (n: number) => Vector1D\n  normalize: () => Vector1D\n}\n\nexport function Vector1D(value: number): Vector1D {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1D | number): Vector1D {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1D | number): Vector1D {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1D | number): Vector1D {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1D {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1D {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1D {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1D | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1D = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Axis } from './axis'\nimport { EventStore } from './eventStore'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { Vector1D } from './vector1d'\nimport { deltaAbs, factorAbs, mathSign } from './utils'\n\ntype Params = {\n  axis: Axis\n  direction: Direction\n  root: HTMLElement\n  target: Vector1D\n  dragFree: boolean\n  dragTracker: DragTracker\n  location: Vector1D\n  animation: Animation\n  scrollTo: ScrollTo\n  scrollBody: ScrollBody\n  scrollTarget: ScrollTarget\n  index: Counter\n  limit: Limit\n  events: EventEmitter\n}\n\nexport type DragHandler = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(params: Params): DragHandler {\n  const { target, scrollBody, dragFree, animation, axis, scrollTo } = params\n  const { root, dragTracker, location, events, limit, direction } = params\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = root\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? root : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number): number {\n    const { scrollTarget, index } = params\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(mathSign(force) * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = deltaAbs(moveScroll, startScroll.get())\n      const diffCross = deltaAbs(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.applyTo(diff))\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(direction.applyTo(rawForce))\n    const speedFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * speedFactor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandler = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { Axis, AxisOption } from './axis'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  pxToPercent: PxToPercent\n}\n\nexport type DragTracker = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOption) => Vector1D\n}\n\nexport function DragTracker(params: Params): DragTracker {\n  const { axis, pxToPercent } = params\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOption): Vector1D {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map(trackPoint => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTracker = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","type Params = {\n  min: number\n  max: number\n}\n\nexport type Limit = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(params: Params): Limit {\n  const { min, max } = params\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? max : min\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  const self: Limit = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","export type PxToPercent = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercent {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercent = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  location: Vector1D\n  speed: number\n  mass: number\n}\n\nexport type ScrollBody = {\n  direction: () => number\n  seek: (v: Vector1D) => ScrollBody\n  settle: (v: Vector1D) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBody\n  useBaseSpeed: () => ScrollBody\n  useMass: (n: number) => ScrollBody\n  useSpeed: (n: number) => ScrollBody\n}\n\nexport function ScrollBody(params: Params): ScrollBody {\n  const { location, speed: baseSpeed, mass: baseMass } = params\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1D): void {\n    v.divide(mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1D): ScrollBody {\n    attraction.set(v).subtract(location)\n    const magnitude = attraction.get()\n    const m = map(magnitude, 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction\n      .normalize()\n      .multiply(m)\n      .subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1D): boolean {\n    const diff = v.get() - location.get()\n    const diffRounded = roundToTwoDecimals(diff)\n    const hasSettled = !diffRounded\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useSpeed(n: number): ScrollBody {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBody {\n    mass = n\n    return self\n  }\n\n  function useBaseSpeed(): ScrollBody {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBody {\n    return useMass(baseMass)\n  }\n\n  const self: ScrollBody = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  limit: Limit\n  location: Vector1D\n  scrollBody: ScrollBody\n}\n\nexport type ScrollBounds = {\n  constrain: (v: Vector1D, pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(params: Params): ScrollBounds {\n  const { limit, location, scrollBody } = params\n  const pullBackThreshold = 10\n  let disabled = false\n\n  function shouldConstrain(target: Vector1D): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(target: Vector1D, pointerDown: boolean): void {\n    if (!shouldConstrain(target)) return\n    const friction = pointerDown ? 0.7 : 0.4\n    const diffToTarget = target.get() - location.get()\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBounds = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Limit } from './limit'\n\nexport type ScrollContainOption = '' | 'trimSnaps' | 'keepSnaps'\n\ntype Params = {\n  contentSize: number\n  viewSize: number\n  alignment: Alignment\n}\n\nexport type ScrollContain = {\n  measure: (scrollSnaps: number[], trim: boolean) => number[]\n}\n\nexport function ScrollContain(params: Params): ScrollContain {\n  const { alignment, contentSize, viewSize } = params\n  const scrollBounds = Limit({ min: -contentSize + viewSize, max: 0 })\n  const alignedWithinView = [alignment.measure(contentSize)]\n  const contentExceedsView = contentSize > viewSize\n\n  function findDuplicates(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = scrollSnaps.lastIndexOf(startSnap) + 1\n    const max = scrollSnaps.indexOf(endSnap)\n    return Limit({ min, max })\n  }\n\n  function measure(scrollSnaps: number[], trim: boolean): number[] {\n    const containedSnaps = scrollSnaps.map(scrollBounds.constrain)\n    const { min, max } = findDuplicates(containedSnaps)\n\n    if (!contentExceedsView) return alignedWithinView\n    if (!trim) return containedSnaps\n    return containedSnaps.slice(min - 1, max + 1)\n  }\n\n  const self: ScrollContain = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  contentSize: number\n  loop: boolean\n}\n\nexport type ScrollLimit = {\n  measure: (scrollSnaps: number[]) => Limit\n}\n\nexport function ScrollLimit(params: Params): ScrollLimit {\n  const { contentSize, loop } = params\n\n  function measure(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit({ min, max })\n  }\n\n  const self: ScrollLimit = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  contentSize: number\n  limit: Limit\n  location: Vector1D\n  pxToPercent: PxToPercent\n}\n\nexport type ScrollLooper = {\n  loop: (vectors: Vector1D[], direction: number) => void\n}\n\nexport function ScrollLooper(params: Params): ScrollLooper {\n  const { contentSize, location, limit, pxToPercent } = params\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit({ min, max })\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1D[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach(v => v.add(loopDistance))\n  }\n\n  const self: ScrollLooper = {\n    loop,\n  }\n  return self\n}\n","import { Limit } from './limit'\r\n\r\ntype Params = {\r\n  limit: Limit\r\n}\r\n\r\nexport type ScrollProgress = {\r\n  get: (n: number) => number\r\n}\r\n\r\nexport function ScrollProgress(params: Params): ScrollProgress {\r\n  const { max, length: scrollLength } = params.limit\r\n\r\n  function get(n: number): number {\r\n    const currentLocation = n - max\r\n    return currentLocation / -scrollLength\r\n  }\r\n\r\n  const self: ScrollProgress = {\r\n    get,\r\n  }\r\n  return self\r\n}\r\n","import { Alignment } from './alignment'\nimport { Counter } from './counter'\nimport { Limit } from './limit'\n\ntype Params = {\n  snapSizes: number[]\n  alignment: Alignment\n  loop: boolean\n}\n\nexport type ScrollSnap = {\n  measure: (index: number) => number\n}\n\nexport function ScrollSnap(params: Params): ScrollSnap {\n  const { snapSizes, alignment, loop } = params\n  const alignments = snapSizes.map(alignment.measure)\n  const distancesBetween = distancesBetweenScrollSnaps()\n\n  function distancesBetweenScrollSnaps(): number[] {\n    const limit = Limit({ min: 0, max: snapSizes.length - 1 })\n    const counter = Counter({ limit, start: 0, loop })\n\n    return snapSizes.map((size, index) => {\n      const next = counter.set(index + 1).get()\n      return size + alignments[index] - alignments[next]\n    })\n  }\n\n  function measure(index: number): number {\n    const sizes = distancesBetween.slice(0, index)\n    return sizes.reduce((a, s) => a - s, alignments[0])\n  }\n\n  const self: ScrollSnap = {\n    measure,\n  }\n  return self\n}\n","import { Counter } from './counter'\nimport { Limit } from './limit'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  index: Counter\n  loop: boolean\n  scrollSnaps: number[]\n  contentSize: number\n  limit: Limit\n  target: Vector1D\n}\n\nexport type Target = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTarget = {\n  byIndex: (target: number, direction: number) => Target\n  byDistance: (force: number, snap: boolean) => Target\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(params: Params): ScrollTarget {\n  const { loop, limit, scrollSnaps, contentSize } = params\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): Target {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map(scrollSnap => scrollSnap - distance)\n      .map(diffToSnap => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = params.index\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): Target {\n    const diffToSnap = scrollSnaps[index] - params.target.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): Target {\n    const target = params.target.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTarget = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { EventEmitter } from './eventEmitter'\nimport { ScrollTarget, Target } from './scrollTarget'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  animation: Animation\n  target: Vector1D\n  index: Counter\n  indexPrevious: Counter\n  scrollTarget: ScrollTarget\n  events: EventEmitter\n}\n\nexport type ScrollTo = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(params: Params): ScrollTo {\n  const { index: indexCurrent, scrollTarget, animation } = params\n  const { indexPrevious, events, target: targetDistance } = params\n\n  function scrollTo(target: Target): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetDistance.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollTo = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { arrayKeys } from './utils'\nimport { Direction } from './direction'\nimport { SlidesInView } from './slidesInView'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  direction: Direction\n  scrollSnaps: number[]\n  viewSize: number\n  location: Vector1D\n  slideSizes: number[]\n  contentSize: number\n  slidesInView: SlidesInView\n}\n\ntype LoopPoint = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\ntype LoopEdge = 'start' | 'end'\n\nexport type SlideLooper = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPoint[]\n}\n\nexport function SlideLooper(params: Params): SlideLooper {\n  const { axis, location: scrollLocation, slidesInView, direction } = params\n  const { contentSize, viewSize, slideSizes, scrollSnaps } = params\n  const ascItems = arrayKeys(slideSizes)\n  const descItems = arrayKeys(slideSizes).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n  const loopStyle = axis.scroll === 'x' ? 'left' : 'top'\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizes[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: LoopEdge): LoopPoint[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map(index => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter(b => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPoint[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPoint[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter(i => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach(loopPoint => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[loopStyle] = `${direction.applyTo(target)}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[loopStyle] = ''\n    })\n  }\n\n  const self: SlideLooper = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { EventStore } from './eventStore'\nimport { ScrollTo } from './scrollTo'\n\ntype Params = {\n  root: HTMLElement\n  scrollTo: ScrollTo\n  slidesToScroll: number\n}\n\nexport type SlideFocus = {\n  addActivationEvents: (slides: HTMLElement[]) => void\n  removeAllEvents: EventStore['removeAll']\n}\n\nexport function SlideFocus(params: Params): SlideFocus {\n  const { scrollTo, slidesToScroll, root } = params\n  const eventStore = EventStore()\n  const removeAllEvents = eventStore.removeAll\n  let lastTabPressTime = 0\n\n  function registerTabPress(event: Event): void {\n    if ((event as KeyboardEvent).keyCode !== 9) return\n    lastTabPressTime = new Date().getTime()\n  }\n\n  function addFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n      if (diffTime > 10) return\n\n      root.scrollLeft = 0\n      const selectedIndex = Math.floor(index / slidesToScroll)\n      scrollTo.index(selectedIndex, 0)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function addActivationEvents(slides: HTMLElement[]): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addFocusEvent)\n  }\n\n  const self: SlideFocus = {\n    addActivationEvents,\n    removeAllEvents,\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\n\ntype Params = {\n  contentSize: number\n  slideSizes: number[]\n  viewSize: number\n  loop: boolean\n  inViewThreshold: number\n}\n\ntype SlideBound = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInView = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBound[]\n}\n\nexport function SlidesInView(params: Params): SlidesInView {\n  const { contentSize, slideSizes, viewSize } = params\n  const { inViewThreshold, loop } = params\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const scrollSnaps = arrayKeys(slideSizes).map(scrollSnap)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBound[], loopOffset) => {\n    return a.concat(findSlideBounds(loopOffset, threshold))\n  }, [])\n\n  function scrollSnap(index: number): number {\n    const span = slideSizes.slice(0, index)\n    return span.reduce((a, s) => a - s, 0)\n  }\n\n  function findSlideBounds(offset: number, threshold?: number): SlideBound[] {\n    const thresholds = slideSizes.map(s => s * (threshold || 0))\n    return scrollSnaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInView = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { Direction } from './direction'\nimport { roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  container: HTMLElement\n  direction: Direction\n}\n\nexport type Translate = {\n  clear: () => void\n  to: (vector: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(params: Params): Translate {\n  const { axis, container, direction } = params\n  const containerStyle = container.style\n  const translate = axis.scroll === 'x' ? x : y\n  const roundToTwoDecimals = roundToDecimals(2)\n\n  let disabled = false\n  let location = 0\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(v: Vector1D): void {\n    const target = roundToTwoDecimals(v.get())\n    if (disabled || location === target) return\n\n    getComputedStyle(container).transform\n    containerStyle.transform = translate(direction.applyTo(target))\n    location = target\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n    location = 0\n  }\n\n  const self: Translate = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation } from './animation'\nimport { Axis } from './axis'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragHandler } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Limit } from './limit'\nimport { Options } from './options'\nimport { PxToPercent } from './pxToPercent'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollBounds } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper } from './scrollLooper'\nimport { ScrollProgress } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { SlideLooper } from './slideLooper'\nimport { SlideFocus } from './slideFocus'\nimport { SlidesInView } from './slidesInView'\nimport { Translate } from './translate'\nimport { arrayKeys, groupArray } from './utils'\nimport { Vector1D } from './vector1d'\n\nexport type Engine = {\n  axis: Axis\n  direction: Direction\n  animation: Animation\n  scrollBounds: ScrollBounds\n  scrollLooper: ScrollLooper\n  scrollProgress: ScrollProgress\n  index: Counter\n  indexPrevious: Counter\n  limit: Limit\n  location: Vector1D\n  options: Options\n  pxToPercent: PxToPercent\n  scrollBody: ScrollBody\n  dragHandler: DragHandler\n  slideFocus: SlideFocus\n  slideLooper: SlideLooper\n  slidesInView: SlidesInView\n  target: Vector1D\n  translate: Translate\n  scrollTo: ScrollTo\n  scrollTarget: ScrollTarget\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: Options,\n  events: EventEmitter,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const axis = Axis(scrollAxis)\n  const pxToPercent = PxToPercent(axis.measure(container))\n  const viewSize = pxToPercent.totalPercent\n  const slideSizes = slides.map(axis.measure).map(pxToPercent.measure)\n  const slideIndexes = arrayKeys(slideSizes)\n  const groupedSizes = groupArray(slideSizes, slidesToScroll)\n  const snapSizes = groupedSizes.map(g => g.reduce((a, s) => a + s))\n  const contentSize = slideSizes.reduce((a, s) => a + s, 0)\n  const alignment = Alignment({ align, viewSize })\n  const scrollSnap = ScrollSnap({ snapSizes, alignment, loop })\n  const defaultSnaps = arrayKeys(snapSizes).map(scrollSnap.measure)\n  const contain = ScrollContain({ alignment, contentSize, viewSize })\n  const shouldContain = !loop && containScroll !== ''\n  const trimSnaps = containScroll === 'trimSnaps'\n  const containedSnaps = contain.measure(defaultSnaps, trimSnaps)\n  const scrollSnaps = shouldContain ? containedSnaps : defaultSnaps\n  const scrollLimit = ScrollLimit({ loop, contentSize })\n  const limit = scrollLimit.measure(scrollSnaps)\n  const direction = Direction(contentDirection)\n\n  // Index\n  const indexMax = Math.max(0, scrollSnaps.length - 1)\n  const indexSpan = Limit({ min: 0, max: indexMax })\n  const index = Counter({ limit: indexSpan, start: startIndex, loop })\n  const indexPrevious = index.clone()\n\n  // Draw\n  const update = (): void => {\n    if (!loop) {\n      engine.scrollBounds.constrain(target, engine.dragHandler.pointerDown())\n    }\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      events.emit('settle')\n    }\n    if (!settled) {\n      events.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(loopVectors, engine.scrollBody.direction())\n      engine.slideLooper.loop(slides)\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody({\n    location,\n    speed,\n    mass: 1,\n  })\n  const scrollTarget = ScrollTarget({\n    contentSize,\n    index,\n    limit,\n    loop,\n    scrollSnaps,\n    target,\n  })\n  const scrollTo = ScrollTo({\n    animation,\n    events,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n  })\n  const slidesInView = SlidesInView({\n    contentSize,\n    inViewThreshold,\n    loop,\n    slideSizes,\n    viewSize,\n  })\n\n  // DragHandler\n  const dragHandler = DragHandler({\n    animation,\n    axis,\n    direction,\n    dragFree,\n    dragTracker: DragTracker({\n      axis,\n      pxToPercent,\n    }),\n    root,\n    events,\n    index,\n    limit,\n    location,\n    scrollBody,\n    scrollTo,\n    scrollTarget,\n    target,\n  })\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds({\n      limit,\n      location,\n      scrollBody,\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize,\n      limit,\n      location,\n      pxToPercent,\n    }),\n    scrollProgress: ScrollProgress({\n      limit,\n    }),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideFocus: SlideFocus({\n      root,\n      scrollTo,\n      slidesToScroll,\n    }),\n    slideLooper: SlideLooper({\n      axis,\n      contentSize,\n      direction,\n      location,\n      scrollSnaps,\n      slideSizes,\n      slidesInView,\n      viewSize,\n    }),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate({\n      axis,\n      container,\n      direction,\n    }),\n  }\n  return engine\n}\n","type Callback = (evt: EmblaEvent) => void\ntype Listeners = Partial<{ [key in EmblaEvent]: Callback[] }>\n\nexport type EmblaEvent =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitter = {\n  emit: (evt: EmblaEvent) => EventEmitter\n  on: (evt: EmblaEvent, cb: Callback) => EventEmitter\n  off: (evt: EmblaEvent, cb: Callback) => EventEmitter\n}\n\nexport function EventEmitter(): EventEmitter {\n  const listeners: Listeners = {}\n\n  function getListeners(evt: EmblaEvent): Callback[] {\n    const eventListeners = listeners[evt]\n    return eventListeners || []\n  }\n\n  function emit(evt: EmblaEvent): EventEmitter {\n    getListeners(evt).forEach(e => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = getListeners(evt).filter(e => e !== cb)\n    return self\n  }\n\n  const self: EventEmitter = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOption } from './alignment'\nimport { AxisOption } from './axis'\nimport { DirectionOption } from './direction'\nimport { ScrollContainOption } from './scrollContain'\n\nexport type Options = {\n  align: AlignmentOption\n  axis: AxisOption\n  containScroll: ScrollContainOption\n  containerSelector: string\n  direction: DirectionOption\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: Options = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptions = Partial<Options>\n","(function() {\n  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Util = (function() {\n    function Util() {}\n\n    Util.prototype.extend = function(custom, defaults) {\n      var key, value;\n      for (key in defaults) {\n        value = defaults[key];\n        if (custom[key] == null) {\n          custom[key] = value;\n        }\n      }\n      return custom;\n    };\n\n    Util.prototype.isMobile = function(agent) {\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\n    };\n\n    Util.prototype.createEvent = function(event, bubble, cancel, detail) {\n      var customEvent;\n      if (bubble == null) {\n        bubble = false;\n      }\n      if (cancel == null) {\n        cancel = false;\n      }\n      if (detail == null) {\n        detail = null;\n      }\n      if (document.createEvent != null) {\n        customEvent = document.createEvent('CustomEvent');\n        customEvent.initCustomEvent(event, bubble, cancel, detail);\n      } else if (document.createEventObject != null) {\n        customEvent = document.createEventObject();\n        customEvent.eventType = event;\n      } else {\n        customEvent.eventName = event;\n      }\n      return customEvent;\n    };\n\n    Util.prototype.emitEvent = function(elem, event) {\n      if (elem.dispatchEvent != null) {\n        return elem.dispatchEvent(event);\n      } else if (event in (elem != null)) {\n        return elem[event]();\n      } else if ((\"on\" + event) in (elem != null)) {\n        return elem[\"on\" + event]();\n      }\n    };\n\n    Util.prototype.addEvent = function(elem, event, fn) {\n      if (elem.addEventListener != null) {\n        return elem.addEventListener(event, fn, false);\n      } else if (elem.attachEvent != null) {\n        return elem.attachEvent(\"on\" + event, fn);\n      } else {\n        return elem[event] = fn;\n      }\n    };\n\n    Util.prototype.removeEvent = function(elem, event, fn) {\n      if (elem.removeEventListener != null) {\n        return elem.removeEventListener(event, fn, false);\n      } else if (elem.detachEvent != null) {\n        return elem.detachEvent(\"on\" + event, fn);\n      } else {\n        return delete elem[event];\n      }\n    };\n\n    Util.prototype.innerHeight = function() {\n      if ('innerHeight' in window) {\n        return window.innerHeight;\n      } else {\n        return document.documentElement.clientHeight;\n      }\n    };\n\n    return Util;\n\n  })();\n\n  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {\n    function WeakMap() {\n      this.keys = [];\n      this.values = [];\n    }\n\n    WeakMap.prototype.get = function(key) {\n      var i, item, j, len, ref;\n      ref = this.keys;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        item = ref[i];\n        if (item === key) {\n          return this.values[i];\n        }\n      }\n    };\n\n    WeakMap.prototype.set = function(key, value) {\n      var i, item, j, len, ref;\n      ref = this.keys;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        item = ref[i];\n        if (item === key) {\n          this.values[i] = value;\n          return;\n        }\n      }\n      this.keys.push(key);\n      return this.values.push(value);\n    };\n\n    return WeakMap;\n\n  })());\n\n  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {\n    function MutationObserver() {\n      if (typeof console !== \"undefined\" && console !== null) {\n        console.warn('MutationObserver is not supported by your browser.');\n      }\n      if (typeof console !== \"undefined\" && console !== null) {\n        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');\n      }\n    }\n\n    MutationObserver.notSupported = true;\n\n    MutationObserver.prototype.observe = function() {};\n\n    return MutationObserver;\n\n  })());\n\n  getComputedStyle = this.getComputedStyle || function(el, pseudo) {\n    this.getPropertyValue = function(prop) {\n      var ref;\n      if (prop === 'float') {\n        prop = 'styleFloat';\n      }\n      if (getComputedStyleRX.test(prop)) {\n        prop.replace(getComputedStyleRX, function(_, _char) {\n          return _char.toUpperCase();\n        });\n      }\n      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;\n    };\n    return this;\n  };\n\n  getComputedStyleRX = /(\\-([a-z]){1})/g;\n\n  this.WOW = (function() {\n    WOW.prototype.defaults = {\n      boxClass: 'wow',\n      animateClass: 'animated',\n      offset: 0,\n      mobile: true,\n      live: true,\n      callback: null,\n      scrollContainer: null\n    };\n\n    function WOW(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.scrollCallback = bind(this.scrollCallback, this);\n      this.scrollHandler = bind(this.scrollHandler, this);\n      this.resetAnimation = bind(this.resetAnimation, this);\n      this.start = bind(this.start, this);\n      this.scrolled = true;\n      this.config = this.util().extend(options, this.defaults);\n      if (options.scrollContainer != null) {\n        this.config.scrollContainer = document.querySelector(options.scrollContainer);\n      }\n      this.animationNameCache = new WeakMap();\n      this.wowEvent = this.util().createEvent(this.config.boxClass);\n    }\n\n    WOW.prototype.init = function() {\n      var ref;\n      this.element = window.document.documentElement;\n      if ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\n        this.start();\n      } else {\n        this.util().addEvent(document, 'DOMContentLoaded', this.start);\n      }\n      return this.finished = [];\n    };\n\n    WOW.prototype.start = function() {\n      var box, j, len, ref;\n      this.stopped = false;\n      this.boxes = (function() {\n        var j, len, ref, results;\n        ref = this.element.querySelectorAll(\".\" + this.config.boxClass);\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          box = ref[j];\n          results.push(box);\n        }\n        return results;\n      }).call(this);\n      this.all = (function() {\n        var j, len, ref, results;\n        ref = this.boxes;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          box = ref[j];\n          results.push(box);\n        }\n        return results;\n      }).call(this);\n      if (this.boxes.length) {\n        if (this.disabled()) {\n          this.resetStyle();\n        } else {\n          ref = this.boxes;\n          for (j = 0, len = ref.length; j < len; j++) {\n            box = ref[j];\n            this.applyStyle(box, true);\n          }\n        }\n      }\n      if (!this.disabled()) {\n        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n        this.util().addEvent(window, 'resize', this.scrollHandler);\n        this.interval = setInterval(this.scrollCallback, 50);\n      }\n      if (this.config.live) {\n        return new MutationObserver((function(_this) {\n          return function(records) {\n            var k, len1, node, record, results;\n            results = [];\n            for (k = 0, len1 = records.length; k < len1; k++) {\n              record = records[k];\n              results.push((function() {\n                var l, len2, ref1, results1;\n                ref1 = record.addedNodes || [];\n                results1 = [];\n                for (l = 0, len2 = ref1.length; l < len2; l++) {\n                  node = ref1[l];\n                  results1.push(this.doSync(node));\n                }\n                return results1;\n              }).call(_this));\n            }\n            return results;\n          };\n        })(this)).observe(document.body, {\n          childList: true,\n          subtree: true\n        });\n      }\n    };\n\n    WOW.prototype.stop = function() {\n      this.stopped = true;\n      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);\n      this.util().removeEvent(window, 'resize', this.scrollHandler);\n      if (this.interval != null) {\n        return clearInterval(this.interval);\n      }\n    };\n\n    WOW.prototype.sync = function(element) {\n      if (MutationObserver.notSupported) {\n        return this.doSync(this.element);\n      }\n    };\n\n    WOW.prototype.doSync = function(element) {\n      var box, j, len, ref, results;\n      if (element == null) {\n        element = this.element;\n      }\n      if (element.nodeType !== 1) {\n        return;\n      }\n      element = element.parentNode || element;\n      ref = element.querySelectorAll(\".\" + this.config.boxClass);\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        box = ref[j];\n        if (indexOf.call(this.all, box) < 0) {\n          this.boxes.push(box);\n          this.all.push(box);\n          if (this.stopped || this.disabled()) {\n            this.resetStyle();\n          } else {\n            this.applyStyle(box, true);\n          }\n          results.push(this.scrolled = true);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    WOW.prototype.show = function(box) {\n      this.applyStyle(box);\n      box.className = box.className + \" \" + this.config.animateClass;\n      if (this.config.callback != null) {\n        this.config.callback(box);\n      }\n      this.util().emitEvent(box, this.wowEvent);\n      this.util().addEvent(box, 'animationend', this.resetAnimation);\n      this.util().addEvent(box, 'oanimationend', this.resetAnimation);\n      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);\n      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);\n      return box;\n    };\n\n    WOW.prototype.applyStyle = function(box, hidden) {\n      var delay, duration, iteration;\n      duration = box.getAttribute('data-wow-duration');\n      delay = box.getAttribute('data-wow-delay');\n      iteration = box.getAttribute('data-wow-iteration');\n      return this.animate((function(_this) {\n        return function() {\n          return _this.customStyle(box, hidden, duration, delay, iteration);\n        };\n      })(this));\n    };\n\n    WOW.prototype.animate = (function() {\n      if ('requestAnimationFrame' in window) {\n        return function(callback) {\n          return window.requestAnimationFrame(callback);\n        };\n      } else {\n        return function(callback) {\n          return callback();\n        };\n      }\n    })();\n\n    WOW.prototype.resetStyle = function() {\n      var box, j, len, ref, results;\n      ref = this.boxes;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        box = ref[j];\n        results.push(box.style.visibility = 'visible');\n      }\n      return results;\n    };\n\n    WOW.prototype.resetAnimation = function(event) {\n      var target;\n      if (event.type.toLowerCase().indexOf('animationend') >= 0) {\n        target = event.target || event.srcElement;\n        return target.className = target.className.replace(this.config.animateClass, '').trim();\n      }\n    };\n\n    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {\n      if (hidden) {\n        this.cacheAnimationName(box);\n      }\n      box.style.visibility = hidden ? 'hidden' : 'visible';\n      if (duration) {\n        this.vendorSet(box.style, {\n          animationDuration: duration\n        });\n      }\n      if (delay) {\n        this.vendorSet(box.style, {\n          animationDelay: delay\n        });\n      }\n      if (iteration) {\n        this.vendorSet(box.style, {\n          animationIterationCount: iteration\n        });\n      }\n      this.vendorSet(box.style, {\n        animationName: hidden ? 'none' : this.cachedAnimationName(box)\n      });\n      return box;\n    };\n\n    WOW.prototype.vendors = [\"moz\", \"webkit\"];\n\n    WOW.prototype.vendorSet = function(elem, properties) {\n      var name, results, value, vendor;\n      results = [];\n      for (name in properties) {\n        value = properties[name];\n        elem[\"\" + name] = value;\n        results.push((function() {\n          var j, len, ref, results1;\n          ref = this.vendors;\n          results1 = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            vendor = ref[j];\n            results1.push(elem[\"\" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n    WOW.prototype.vendorCSS = function(elem, property) {\n      var j, len, ref, result, style, vendor;\n      style = getComputedStyle(elem);\n      result = style.getPropertyCSSValue(property);\n      ref = this.vendors;\n      for (j = 0, len = ref.length; j < len; j++) {\n        vendor = ref[j];\n        result = result || style.getPropertyCSSValue(\"-\" + vendor + \"-\" + property);\n      }\n      return result;\n    };\n\n    WOW.prototype.animationName = function(box) {\n      var animationName, error;\n      try {\n        animationName = this.vendorCSS(box, 'animation-name').cssText;\n      } catch (error) {\n        animationName = getComputedStyle(box).getPropertyValue('animation-name');\n      }\n      if (animationName === 'none') {\n        return '';\n      } else {\n        return animationName;\n      }\n    };\n\n    WOW.prototype.cacheAnimationName = function(box) {\n      return this.animationNameCache.set(box, this.animationName(box));\n    };\n\n    WOW.prototype.cachedAnimationName = function(box) {\n      return this.animationNameCache.get(box);\n    };\n\n    WOW.prototype.scrollHandler = function() {\n      return this.scrolled = true;\n    };\n\n    WOW.prototype.scrollCallback = function() {\n      var box;\n      if (this.scrolled) {\n        this.scrolled = false;\n        this.boxes = (function() {\n          var j, len, ref, results;\n          ref = this.boxes;\n          results = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            box = ref[j];\n            if (!(box)) {\n              continue;\n            }\n            if (this.isVisible(box)) {\n              this.show(box);\n              continue;\n            }\n            results.push(box);\n          }\n          return results;\n        }).call(this);\n        if (!(this.boxes.length || this.config.live)) {\n          return this.stop();\n        }\n      }\n    };\n\n    WOW.prototype.offsetTop = function(element) {\n      var top;\n      while (element.offsetTop === void 0) {\n        element = element.parentNode;\n      }\n      top = element.offsetTop;\n      while (element = element.offsetParent) {\n        top += element.offsetTop;\n      }\n      return top;\n    };\n\n    WOW.prototype.isVisible = function(box) {\n      var bottom, offset, top, viewBottom, viewTop;\n      offset = box.getAttribute('data-wow-offset') || this.config.offset;\n      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;\n      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;\n      top = this.offsetTop(box);\n      bottom = top + box.clientHeight;\n      return top <= viewBottom && bottom >= viewTop;\n    };\n\n    WOW.prototype.util = function() {\n      return this._util != null ? this._util : this._util = new Util();\n    };\n\n    WOW.prototype.disabled = function() {\n      return !this.config.mobile && this.util().isMobile(navigator.userAgent);\n    };\n\n    return WOW;\n\n  })();\n\n}).call(this);\n","/*global jQuery */\r\n/* Contents\r\n// ------------------------------------------------>\r\n\t1.  Background INSERT\r\n\t2.  HEADER AFFIX\r\n\t3.\tAJAX MAILCHIMP\r\n\t4.  AJAX CAMPAIGN MONITOR \r\n\t5.  OWL CAROUSEL\r\n    6.  SCROLL TO\r\n    7.  Navbar Toggler\r\n\t8.  WOW\r\n\t9.  Youtube Background\r\n*/    \r\n\r\n\r\n/* ------------------  Background INSERT ------------------ */\r\n\r\nvar bgSection = document.querySelectorAll(\".bg-section\");\r\nbgSection.forEach(function(el) {\r\n    var bgSrc = el.children[0].src;\r\n    var bgUrl = 'url(' + bgSrc + ')';\r\n    el.parentNode.style[\"backgroundImage\"] = bgUrl;\r\n    el.parentNode.classList.add(\"bg-section\")\r\n    el.remove();\r\n});\r\n\r\n\r\n/* ------------------ HEADER AFFIX ------------------ */\r\n\r\nwindow.addEventListener(\"scroll\", () => {\r\n    if(window.scrollY > 105)\r\n        document.querySelector(\".navbar-sticky\").classList.add(\"navbar-fixed\");\r\n    else\r\n        document.querySelector(\".navbar-sticky\").classList.remove(\"navbar-fixed\");\r\n})\r\n\r\n/* ------------------ OWL CAROUSEL ------------------ */\r\n\r\nimport EmblaCarousel from 'embla-carousel';\r\nconst wrap = document.querySelector(\".embla\");\r\nconst viewPort = wrap.querySelector(\".embla__viewport\");\r\nconst prevBtn = wrap.querySelector(\".embla__button--prev\");\r\nconst nextBtn = wrap.querySelector(\".embla__button--next\");\r\nconst embla = EmblaCarousel(viewPort, {\r\n    slidesToScroll: 1,\r\n    loop: true,\r\n    containScroll: \"trimSnaps\"\r\n});\r\nconst disablePrevAndNextBtns = disablePrevNextBtns(prevBtn, nextBtn, embla);\r\n\r\nsetupPrevNextBtns(prevBtn, nextBtn, embla);\r\n\r\nembla.on(\"select\", disablePrevAndNextBtns);\r\nembla.on(\"init\", disablePrevAndNextBtns);\r\n// $(\".owl-carousel\").each(function() {\r\n//     var $Carousel = $(this);\r\n//     $Carousel.owlCarousel({\r\n//         loop: $Carousel.data('loop'),\r\n//         autoplay: $Carousel.data(\"autoplay\"),\r\n//         margin: $Carousel.data('space'),\r\n//         nav: $Carousel.data('nav'),\r\n//         dots: $Carousel.data('dots'),\r\n//         dotsSpeed: $Carousel.data('speed'),\r\n//         responsive: {\r\n//             0: {\r\n//                 items: 1\r\n//             },\r\n//             600: {\r\n//                 items: $Carousel.data('slide-res')\r\n//             },\r\n//             1000: {\r\n//                 items: $Carousel.data('slide'),\r\n//             }\r\n//         }\r\n//     });\r\n// });\r\n\r\n\r\n/* ------------------ NAVBAR SCROLLING SECTION ------------------ */\r\n\r\nif (document.querySelector('.body-scroll')) {\r\n    window.addEventListener(\"scroll\", function () {\r\n        document.querySelectorAll('section').forEach(function (el) {\r\n            let sectionID = el.getAttribute(\"id\"),\r\n                sectionTop = el.offsetTop - 100,\r\n                sectionHight = el.offsetHeight,\r\n                wScroll = window.scrollY,\r\n                navHref = document.querySelector(\"a[href='#\" + sectionID + \"']\"),\r\n                nav = navHref.parentNode;\r\n            if (wScroll > sectionTop - 1 && wScroll < sectionTop + sectionHight - 1) {\r\n                nav.classList.add('active');\r\n                let els = nav.parentNode.children;\r\n                [].slice.call(els).forEach((el) => {\r\n                    if(el != nav)\r\n                        el.classList.remove(\"active\")\r\n                })\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n/* ------------------  NAVBAR SCROLL TO ------------------ */\r\n\r\nfunction scrollTo(element = document.documentElement, to = 0, duration = 1000) {\r\n    var start = element.scrollTop,\r\n        change = to - start,\r\n        currentTime = 0,\r\n        increment = 20;\r\n        \r\n    var animateScroll = function(){        \r\n        currentTime += increment;\r\n        var val = Math.easeInOutQuad(currentTime, start, change, duration);\r\n        element.scrollTop = val;\r\n        if(currentTime < duration) {\r\n            setTimeout(animateScroll, increment);\r\n        }\r\n    };\r\n    animateScroll();\r\n}\r\n\r\nMath.easeInOutQuad = function (t, b, c, d) {\r\n    t /= d/2;\r\n    if (t < 1) return c/2*t*t + b;\r\n    t--;\r\n    return -c/2 * (t*(t-2) - 1) + b;\r\n};\r\n\r\ndocument.querySelectorAll('.nav-item .nav-link').forEach((a) => {\r\n    a.addEventListener(\"click\", (event) => {\r\n        var target = document.querySelector(a.getAttribute('href'));\r\n        let els = a.parentNode.parentNode.children;\r\n        [].slice.call(els).forEach((el) => {\r\n                el.classList.remove(\"active\")\r\n        })\r\n        a.parentNode.parentNode.classList.add('active');\r\n\r\n        if (target) {\r\n            event.preventDefault();\r\n            scrollTo(document.documentElement, target.offsetTop - 100, 1000);\r\n            \r\n        }\r\n\r\n        // If click link and navabr is show\r\n        if (document.querySelector('.navbar-collapse').classList.contains('show')) {\r\n            document.querySelector('.navbar-collapse').classList.toggle('show');\r\n            document.querySelector('.navbar-toggler-icon').classList.toggle('active');\r\n            document.querySelector('.navbar-toggler').classList.toggle('collapsed');\r\n        }\r\n    })\r\n})\r\n\r\n\r\n/* ------------------  Navbar Toggler ------------------ */\r\n\r\ndocument.querySelector('.navbar-toggler').addEventListener(\"click\", (evt) => {\r\n    evt.currentTarget.classList.toggle(\"collapsed\")\r\n    document.querySelector(\".navbar-toggler-icon\").classList.toggle(\"active\");\r\n    document.querySelector(\"#navbarContent\").classList.toggle(\"show\");\r\n});\r\n\r\n\r\n/* ------------------  WOW Animated ------------------ */\r\n\r\nlet WOW = require(\"wowjs\").WOW\r\nvar wow = new WOW({\r\n    boxClass: 'wow',\r\n    animateClass: 'animated',\r\n    offset: 50,\r\n    mobile: false,\r\n    live: true\r\n\r\n});\r\nwow.init();\r\n\r\n/* ------------  Contact Form */\r\ndocument.querySelector(\"form.ContactForm\").addEventListener(\"submit\", (e) => {\r\n    e.preventDefault();\r\n    let form = e.currentTarget;\r\n    let xhr = new XMLHttpRequest();\r\n\r\n    xhr.open(\"GET\", \"\", true);\r\n\r\n    xhr.onreadystatechange = function() {\r\n        document.querySelector(\".ContactForm\").classList.add(\"hidden\");\r\n        if (this.readyState === XMLHttpRequest.DONE) {\r\n            console.log(\"this.status = \" + this.status);\r\n            let view = document.querySelector(this.status === 201 ? \".ContactConfirm\" : \".ContactError\");\r\n            view.classList.remove(\"hidden\");\r\n            view.style[\"visibility\"] = \"visible\";\r\n            view.style[\"animation-name\"] = \"fadeInUp\";\r\n        }\r\n    }\r\n\r\n    xhr.send(new FormData(form));\r\n})\r\n\r\ndocument.querySelector(\".GoToForm\").addEventListener(\"click\", () => {\r\n    document.querySelector(\".ContactForm\").classList.remove(\"hidden\");\r\n    document.querySelector(\".ContactError\").classList.add(\"hidden\");\r\n})","import \"../css/main.scss\"\n\n// import \"./vendor.js\";\nimport \"./functions.js\";\n\nfunction FaqExpand(e) {\n    let myEl = e.currentTarget;\n    document.querySelectorAll(\".faq.active\").forEach( (el) => {\n        if(el != myEl)\n            el.classList.remove(\"active\")\n    })\n    myEl.classList.toggle(\"active\");\n}\n\ndocument.querySelectorAll(\".faq\").forEach((faq) => {\n    faq.addEventListener(\"click\", FaqExpand);\n})"]}